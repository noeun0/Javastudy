## 200721

# 변수



자바는 다른 언어에 비해 자료형 선언 같은 것들이 엄격하다. 컴파일 단계에서 예상되는 문제점을 예측할 수 있다.  금융이나 과학적 계산처럼 엄격함이 요구되는 분야에 주로 사용

\를 " 앞에 위치시키면 단순히 문자로 해석하도록 할 수 있다.

실수형 변수 : double  8byte / float 4byte  부동소수점 근삿값으로 소수를 표현    mbyte  : 2^(m*8) 개의 숫자 가능 0중심

 ```
float a = 2.0F 
float a = (float)100.0
//정수가 아닌 실수값은 그 자체로 double 값이다. 그러므로 float에 저장하기 위해선 형변환을 해야한다.
long a = 2147483648L //int에 저장될 수 있는 최댓값을 넘었기 때문에
 ```

```
byte a = 100;
short b = 200; //이건 가능 int 허용하기 때문   
```



byte -> short char -> int -> long -> float -> double

자동형 변환은 작은 범위에서 넓은 데이터 타입으로의 변환만 허용이고 형변환을 따로 안해줘도 저절로 상수 값이 변환되어 변수에 저장되는 것이다.

명시적 형변환은 (데이터타입)데이터 값 형태로 직접 써서 변환 시켜주는 것이다. 이는 넓은 데이터에서 좁은 데이터로 바꾸는 데 쓰임 이는 데이터 손실이 일어나므로 버그를 없애기위해 사용



문자형 변수 : char 2byte

문자열 : string 글자들의 집합  2*글자수 byte

모든 객체는 힙 메모리에 위치한다. 힙메모리는 프로세스가 실행될 때 운영체계로 부터 할당, 자바는 자바 가상머신이 실행될 때 운영체계로 부터 힙메모리를 할당받는다. 힙메모리는 고정되어 있을 수도 가변적일 수도 있다. 초기힙, 최대 힙 메모리의 양을 설정할 수도 있다. 최대는 2GB! 따라서 string 클래스의 문자열의 최대 가능 길읻 2GB가 한계

```
java-Xms16s Xms128m Myclass
(초기값 16, 최대 힙 메모리 128)
```



-> string 클래스의 문자열 길이의 한계는 하드웨어 머신과 운영체계에서 허용하는 최대한의 크기까지 가능. 특별히 규약에서 제약하는 사항은 없다. 자바 가상 머신에 따라 힙 메모리 할당에 옵션 설정이 있을 수 있다.

 변수 두개 동시 선언 가능

alert?



# 연산자



정수 * 정수 - 정수

정수*실수 - 실수 로 형변환



boolean 참 거짓을 의미하는 데이터 타입

.equals 는 문자열을 비교할 때 사용하는 메소드 a.equals(b)



#### 산술 연산자

+, -, *, /, %, 

##### 증감 연산자 

++, --



#### 관계연산자 : 두수를 비교하여 참(1)거짓(0) 을 결과로 얻음

== 같다, != 같지않다, >, >=, <, <= 



#### 비트 연산자 : 이진법 0,1로 연산하여 결과를 얻는 연산자

& and  모든 비트가 1일때만 1 이더넷 주소 서브넷마스크 

^ xor  모든 비트가 같으면 0 하나라도 다르면 1

| or  모든비트 중 한비트라도 1이면 1

~ not 각 비트의 부정 0이면 1 1이면 0

```
a=5
b=7

a&b = 000...00000000...000000 0101
	  000...00000000...000000 0111
      ----------------------------
      000...00000000...000000 0101 = 5
      
a|b = 000...00000000...000000 0101
	  000...00000000...000000 0111
      ----------------------------
      000...00000000...000000 0111 = 7 

a^b = 000...00000000...000000 0101
	  000...00000000...000000 0111
      ----------------------------
      000...00000000...000000 0010 = 2

~b =  000...00000000...000000 0111
	  ----------------------------
	  111...11111111...111111 1000  = 7의 보수 -8
	  
```



<< 왼쪽 시프트*2 비트를 왼쪽으로 이동 >> 오른쪽으로 이동 /2 : 이진법으로 바꾼 후 이동

```
d=5
d>>1 //000,,,0,0000000000101  -> 000,,,0,0000000000010

결과값 : 2
```



#### 대입 연산자 : 연산 후 결과를 대입하는 연산식을 간략하게 입려할 수 있도록 대입 연산자를 제공. 대입 연산자는 산술, 관계, 비트, 논리 연산자에 모두 적용 가능

+=, -=, *=, /=, %=, <<=, >>=  



#### 조건연산자

조건 ? 수식 1 : 수식2;

```
a=1, b=2, c=3, d=4

b*=a>b?a:b  // a>b? x b가 선택 b*=b -> 2x2=4

c-=a<b?a-b:b-a; a<b? o a-b가 선택 c-=a-b  c-=-1 3-(-1) =4

c+=b<b? ++a:b++; b<b? x b++가 선택 b++ = 2 3+=2 =5

```





#### 기타 연산자

sizeof 자료형 크기를 표시한다 / 출력 형태

, 한줄에 두개이상의 수식을 작성하거나 변수 정의.  순서는 왼쪽에서 오른쪽

(자료형) 자료형을 다른 자료형으로 변환하는 연산자



#### 우선순위

단항 연산자(!, ~, ++, --, sizeof) 

이항연산자(산술(*/% +-) 시프트(<< >>), 관계(<=, <, >, >=, ==, !=) 비트(&, ^, |) 논리(&&, ||)) 

삼항연산자 (? :)

대입연산자 = += -= *= /= %= <<= >>=

순서연산자(,)

```
a=2, b=3, c=4, d=5

1. d*=10-b++; b++ = 3 ->  d*=(10-3) -> d=5*7 = 35
2. d+=b*=c/=a; d+(b*(c/a)) -> 5+(3*(4/2)) = 11
3. a-=++d/b--; 6/3 = 2 a-2 = 0
4. b+=c*=a<<2; a<<2 = 8   3+(4*8) = 35
5. a%=c|b&d-b; d-b=2 a%(4|3&2) 

000...00000000...000000 0011
000...00000000...000000 0010
----------------------------
000...00000000...000000 0010 = 2 
000...00000000...000000 0100 
----------------------------
000...00000000...000000 00110 = 6
2%6 = 2

6. c*=d<<=(b==++a);

4*=5<<=(3==3) -> 4*=5<<=1 4*10 = 40


```





# 조건문

if

```
if(true){
then 절
}
```

```
if(){
}else{
}
```

```
if(){
}else if(){
}else{
}
```

스위치

```
switch(입력값){
case 1 :
case 2 :
case 3 :
...
default: //입력값이 주어진 케이스에 없으면 실행
}
```

각 케이스마다 break가 없으면 처음 실행된 case 부터 아래로 쭉쭉 다 실행

break 가 있으면 해당 케이스만 하고 즉시 중지



# 반복문

```
while(i<10){
i++
}
```

조건에 true를 넣어버리면 무한반복 

```
for(초기화; 종료조건; 반복실행){
}
```

초기값을 0으로 , 원하는 반복횟수m를 i<m 로 



for(int i=1; i<=5; i++){

 m+= i*2

}



for (int i=0, i<=10, i+=2){

m+=i

}

# 배열

```
string[] classgroup = { "a","b","c"};
string[] members = new string[3]; // 3명이고 인덱스는 0,1,2
```

string[]는 문자열의 배열이라는 의미. 배열을 선언할 때는 데이터 타입 뒤에 []를 붙혀야함



```
for (string e : members) {
e에 관한 실행문
}
```

배열 members의 값을 변수 e에 담아서 중괄호 구간 안으로 전달해 줌



한계 : 초기화 할 때 크기가 정해짐  -> 컬렉션 기능을 이용하면 유연하게 사용 가능



# 메소드 정의와 호출

```
public static void main(string[] args){

  numbering(); // 호출된 메소드

}

public static void numbering(){ //메소드 정의
}
```

정의와 호출의 차이점  : ()로 끝나면 호출된 메소드 {}로 되면 정의



main

main 메소드는 규칙 , 만들고 싶은 프로그램이 있다면 반드시 main 안에 넣어야함

메소드를 씀으로서 재활용이 가능 -> 중복되는 부분을 없앨 수 있고 수정이 용이하다



- 외부 자극 : 입력, 반응 : 출력 /메소드는 프로그램 안에서 동작하는 하나의 작은 프로그램. 입력값에 따라  출력값도 달라지게 할수도

-> 매개변수 parameter 를 통해 이루어진다. 메소드를 정의할 때 ()안에 변수를 넣고 호출할때 인자값을 넣어서 호출. 복수값도 가능

- 결과값을 화면에 출력하지 않고 그냥 반환 받고 싶을 때는 return을 사용한다. return 은 값을 반환시키기도 하지만 메소드를 중단시키기도 한다. 또한 이때는 반환할 값의 데이터 형식을 메소드의 이름 옆에 명시해주어야한다. 반환값이 없으면 void

```
 public static void main(String[] args) {
        String result = numbering(1, 5);
        System.out.println(result);
```

여러개의 데이터를 반환받고 싶을 땐? 배열을 이용한다.

```
public class ReturnDemo4 {
 
    public static String[] getMembers() {
        String[] members = { "최진혁", "최유빈", "한이람" };
        return members;
    }
 
    public static void main(String[] args) {
        String[] members = getMembers();
        }
```

------------------------------------------------------------







# 입력과 출력

string[] args : 매개변수( 메소드가 호출될 때 전달된 입력 값을 메소드 내부로 전달. ) 입력값의 파라미터로 동작

```
package org.opentutorial.javatutorials.io;

class lnputdemo{
	public ststic void main(String[] args){
		sytem.out.println(args.length); // 입력받은 배열의 길이를 출력한다.
	}
}
```

for-each 구문

```
class InputForeachDemo{
    public static void main(String[] args){
        for(String e : args){
            System.out.println(e);
        }
    } // 사용자로부터 arge라는 문자열배열에 값을 입력받아서 그 값들을 for문을 이용해 하나씩 출력
}
```



#### 앱이 실행중에 입력 받기

scanner : 자바에서 기본적으로 제공하는 라이브러리. 사용자의 입력을 쉽게 잡을 수 있다.

```
package org.opentutorial.javatutorials.io;

import java.util.Scanner; //scanner 로드
 
public class ScannerDemo {
 
    public static void main(String[] args) {  //입력값을 입력하지 않았기때문에 아무런 값이 입력되지 않는다.
        Scanner sc = new Scanner(System.in); // system.in = 사용자가 입력한 값, 스캐너라는 객체를 새로 만들어서 사용자가 입력한 값을 알아냄 ()안에 파일명이 들어가면 파일의 내용을 스캐닝/ 알아낸 것을 sc라는 변수에 담아냄. 스캐너 객체를 sc로 제어할 수 있다. 
        
        int i = sc.nextInt(); //실행을 멈추고 입력을 다 하는걸 기다리고 있는 상태에서 int 값을 입력받으면 아이라는 변수에 담김
        System.out.println(i*1000); 
        sc.close();
    }
```

-> 한번만 입력하고 결과값이 나오면 종료



변수형 변수 = new 변수형()

메소드 변수 = new 메소드()





#### 계속하여 상호작용하는 프로그램

```
package org.opentutorials.javatutorials.io;
 
import java.util.Scanner;
 
public class Scanner2Demo {
 
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        while(sc.hasNextInt()) { //입력한 값이 정수면 true 반복문 실행, 숫자가 아니라면 반복문 종료
            System.out.println(sc.nextInt()*1000); // 사용자가 입력한 정수값에 1000을 곱하고 출력 
        }
        sc.close();
    }
 
}
```

- system.in : 실행되면 자바는 사용자의 입력이 있을 때 까지 변수 i에 값을 할당하지 않고 대기상태에 있게 된다. 

출력

```
System.out.print(); // 다음에 출력하는 것이 바로 뒤에 붙어서 출력
System.out.println(); // 다음에 출력하는 것이 한줄 띄어서 출력 출력이 된후 한줄이 띄어짐
```



#### 파일의 내용을 입력값으로 유입시키는 프로그램

```
package org.opentutorials.javatutorials.io;
 
import java.util.Scanner; 
import java.io.*;
 
public class Scanner3Demo {
 
    public static void main(String[] args) {
        try {
            File file = new File("out.txt"); // 파일 객체를 생성 해서 파일 out.txt를 넣음
            Scanner sc = new Scanner(file); //변수안에 있는 파일을 스캐너가 입력값으로 받아와서 스캐너 변수에 저장 
            while(sc.hasNextInt()) {
                System.out.println(sc.nextInt()*1000); 
            }
            sc.close();
        } catch(FileNotFoundException e){ //파일을 찾을 수 없는 경우 화면에 출력하고 예외처리
            e.printStackTrace();
        }
         
    }
 
}
```



# 객체지향 프로그래밍 OOP

로직을 상태와 행위로 이루어진 객체로 만드는 것. 기계의 부품처럼 조립해서 하나의 프로그램으로 만드는 것

프로시저보다는 명령과 데이터로 구성된 객체를 중심으로 하는 프로그래밍. 한 프로그램을 다른 프로그램에서 이용 가능



- 장단점

  상속을 통한 재사용과 시스템 확장이 용이

  코드의 재활용성이 높다. 이식성이 높다

  자연적인 모델링에 의해 분석과 설계를 쉽고 효율적으로 할 수 있다. 

  사용자와 개발자 사이의 이해를 쉽게 해줌

  대형 프로그램의 작성이 용이

  소프트웨어 개발 및 유지보수가 용이

  

  구현을 지원해주는 정형화된 분석 및 설계 방법이 없다

  구현 시 처리 시간이 지연







#### 클레스와 인스턴스 그리고 객체

##### 접근 지정자 class 클래스명 {

필드

메소드

##### }

설계도 객체를 정의해 놓은 것. 객체를 만들기 위한것

연관되어 있는 변수와 메소드의 집합

##### 객체

실제로 존재하는 것 ( 사물, 개념)

클래스 모양 그대로 생성된 실체

```
Calculator c1 = new Calculator();
// 클래스 calculator를 구체적인 제품으로 만드는 명령. 이렇게 만들어진 제품이 인스턴스
new를 통해 만든 인스턴스를 변수 c1에 담았다. 이제 c1을 갖고 인스턴스를 제어할 수 있다. 
```



##### 인스턴스

객체를 클래스의 인스턴스라고 한다. 



클래스 안에 메소드가 포함되어있다. 그 메소드는 클래스의 구성으로 만들어진 객체를 이용할 수 있다.

메소드는 각각의 역할이 있음

그 클래스의 구성을 갖고 다른 클래스 안의 메인 메소드에서 객체를 생성해줄 수 있다.

```
package myjava;
class Calculator{
    static double PI = 3.14; //static을 맴버 앞에 붙이면 클래스의 맴버가 된다.
    int left, right; //클래스의 구성 파이, 레프트, 라이트
    static int base = 0; //클래스 변수를 만들기 위해선 앞에 스테틱을 써준다!!!
    //메소드를 세개 만들어 줬다. 변수를 넣는 메소드. 덧셈하는 메소드 . 평균 구하는 메소드
    public void setOprands ( int left, int right) {
        this.left = left; //객체.setOprands(변수, 변수)를 하게 되면 객체안에 값이 저장된다. 값을 메인 메소드에서 넣을 수 있는 방법! 이렇게 안하면 일일이 넣어줘야겠지..
        this.right = right; //
    }
    
    public void sum() { //합해서 출력까지 해주는 것..!
        System.out.println(this.left + this.right+base);
        
    }
    public void avg() { //평균을 구해서 출력까지 해주는 것!
        System.out.println(this.left + this.right/2+base);
    }
}    
    
    
public class Caculatordemo {
//나눌 이유가 딱히 없는 것 같은데 나눈 이유를 생각해보자면 위에 클래스는 숫자 객체를 만들 구성들과  그 구성을 이용해 만들
   // 메소드를 모아놨다. 그러면 메인 메소드 에서는 그 메소드를 사용하기만 하면 된다!
        public static void main(String[] args) {
     
            Calculator c1 = new Calculator();
            c1.setOprands(3,6);
            Calculator.base=10; // 클래스 변수는 클래스.변수 로 써준다!!!!!
            System.out.println(c1.PI); // c1객체 생성 했고 c1의 파이값 출력했고.. 
            c1.sum(); //항상 메소드를 사용할땐 사용할 객체.메소드!!!!
            c1.avg();
            
            
     
            Calculator c2 = new Calculator();
            System.out.println(c2.PI);
            c1.sum(); //항상 메소드를 사용할땐 사용할 객체.메소드!!!!
            c1.avg();
            System.out.pr02intln(Calculator.PI);
     
        }
}
```



020723

# 메소드 : 객체의 행동 또는 기능



#### 입력값이 있고 리턴값도 있는 메소드가 평범한 상태

```
public int sum(int a, intb){   
	return a+b;
}
```

위와 같은 메소드는 리턴값받을변수 = 객체.메소드명(입력인수1, 입력인수2, ...) 로 사용됨

```
Test myTest = new Test();
int c = myTest.sum(a,b);
```



#### 입력값이 없을 경우 - 메소드명()

```
public String say() {
	return "hi"
} // 입력값 없음 리턴 값 string
```

```
Test mytest = new Test();
String a = mytest.say();
System.out.println(a);
```

 hi



#### 리턴 값이 없는 경우 void

```
public void sum (int a , int b){
	System.out.println(a+"과 "+b+"의 합은 "+(a+b)+"입니다.");
}
```

```
Test myTest = new Test();
myTest.sum(3,4);
```

3과 4의 합은 7입니다.



#### return의 또 다른 쓰임새

특별한 경우 메소드를 빠져나가기를 원할 때 사용할 수 있다.

```
public void say_nick(String nick){
	if ("fool".equals(nick)){ //입력값이 fool하고 일치한다면 바로 종료 호출했던 곳으로 돌아감
		return;// 많이 쓰면 가독성이 떨어짐 모아서 한군데에 쓰자
	}
	System.out.println("나의 별명은 " +nick+"입니다.");
}
```

단 리턴 값이 void 일때만 가능하다. 리턴자료형이 명시되어 있는 메소드에서 return 문만 작성하면 컴파일시 오류가 난다. -> return null 을 쓰면됨

#### 메소드 내에서 선언된 변수의 유효 범위 스코프

```
class Test {
    public void vartest(int a) {
        a++;
    }

    public static void main(String[] args) { 
        int a = 1; // a라는 int자료형의 변수를 생성하고 1을 대입
        Test myTest = new Test();
        myTest.vartest(a);//메소드에 a를 주어 호출 
        System.out.println(a); //a값을 출력 이때 a는 메소드 내에서 사용되어지는 변수 1 이 들어있기 때문에 1이 출력
    }
}
```

메소드에서만 쓰이는 변수는 메소드 밖의 변수들과 전혀 상관이 없다. 

이런 메소드 내에서 쓰는 변수를 로컬변수라 한다.

원시/참조 자료형 class로 생성되는 것들

  



그럼 원하는 값을 얻기 위해선?

```
public int vartest(int a) {
    a++;
*** return a; // a값을 리턴한다.
}

public static void main(String[] args) {
    int a = 1;
    Test myTest = new Test();
*** a = myTest.vartest(a); 메소드의 리턴값으로 나와 a값이 변경된다.
    System.out.println(a);
}
```



#### 객체를 넘기는 방법

```
public class Test{

	int a;//속성
	
	public void vartest(Test test){
		test.a++; //객체를 입력받아 해당 객체의 객체변수 a의 값을 1만큼 증가시킴
	}
}

public static void main(String[] args){
	Test myTest = new Test();
	myTest.a = 1;
	myTest.vartest(myTest); // Test 클래스의 객체인 myTest를 넘기도록 다음과 같이 수정했다.
	System.out.println(myTest.a);
}

```

파라미터가 객체. 객체를 전달 받으면 메소드 내의 객체는 전달 받은 객체 그 자체로 수행된다. 

따라서 입력으로 전달받은 myTest 객체의 객체변수 a의 값이 증가하게 되는 것이다.

값인지 객체인지 구별하는 기준 : 입력항목의 자료형이 primitive 자료형인지 아닌지에 따라 나뉜다. int자료형과 같은 primitive 자료형은 값이 전달되고 그 이외는 객체가 전달.



#### 객체를 전달하는 대신 this 이용하기

```
package myjava;
public class Test {

    int a; 

    public void vartest() {
        this.a++; // this 를 이용해 해당 객체에 접근할 수 있기 때문에 class자기자신
    }

    public static void main(String[] args) {
        Test myTest = new Test();
        myTest.a = 1;
        myTest.vartest();
        System.out.println(myTest.a);
    }
}
```



#### Call by value

```
package myjava;
class Updater {
    public void update(int count) {
        count++;
    }
}

public class Counter {
    int count = 0;  // 객체변수
    public static void main(String[] args) {        
        Counter myCounter = new Counter();
        myCounter.count=1;
        System.out.println("before update:"+myCounter.count);
        Updater myUpdater = new Updater();
        myUpdater.update(myCounter.count); // 객체변수값을 넘겨줌
        System.out.println("after update:"+myCounter.count);
    }
}
```

1, 1 더해진 값이 출력되지 않는다.

update 메소드는 원시 자료형 값을 전달받았기 때문이다.



-> 객체를 변수로 받기

```
package myjava;
class Updater {
public void update(Counter counter) {
    counter.count++;    
  }
}
class Counter{
    int count=0;
    public static void main(String[] args) {
        Counter mycoun = new Counter();
        mycoun.count=1;
        System.out.println("before update:"+mycoun.count);
// 객체를 변수를 넣어 다른 클래스의 객체의 메소드를 호출
        Updater myup=new Updater();
        myup.update(mycoun);
        System.out.println("after update:"+mycoun.count);
        
    }
}
```



이렇게 메소드의 입력으로 객체를 전달받으면 메소드가 입력받은 객체를 그대로 사용하기 때문에 메소드가 객체의 속성값을 변경하면 메소드 수행 후 변경된 속성값이 그대로 유지



# 상속

클래스 상속 extends 를 이용

자식클래스 extends 부모클래스

```
public class Cat extends Animal{

}
```

Cat 클래스는 Animal 클래스를 상속하게 되었다.

```
package myjava;
public class Cat extends Animal {
    public static void main(String[] args) {
        Cat cat = new Cat();
        cat.setName("catt");
        System.out.println(cat.name);
    }
    
}
```

catt 

자식 클래스에 다른 메소드를 더 추가해서 부모클래스의 기능에 더하여 더 많은 기능을 갖도록 설계한다.

```
.public class Cat extends Animal {
    public void sleep() {
        System.out.println(this.name+" zzz");
    }

    public static void main(String[] args) {
        Cat cat = new Cat();
        cat.setName("Catt");
        System.out.println(cat.name);
        cat.sleep();
    }
}
```



Catt
Catt zzz



IS-A관계

Cat클래스는 Animal클래스를 상속받았다. cat은 Animal에 포함되기 때문에 고양이는 동물이다 라고 표현할 수 있다.

  Cat is a Animal 이라고 말할 수 있는 관계를 IS-A관계 라고 한다.

이 관계에 있을 때 자식 객체는 부모 클래스의 자료형인 것 처럼 사용할 수 있다.

```
Animal cat = new Cat(); // 고양이 클래스로 만든 객체는 동물 자료형이다.
```







하지만 이 반대는 불가

```
Cat cat = new Animal(); // 동물 클래스로 만든 객체는 고양이 이다. > No
```



* 자바에서 만드는 모든 클래스는 Object라는 클래스를 상속받게 되어있다. 우리가 만드는 Animal 클래스는 다음과 기능적으로 완전히 동일하다. 하지만 굳이 아래 코드처럼 Object 클래스를 상속하도록 코딩하지 않아도 자바에서 만들어지는 모든 클래스는 Object 클래스를 자동으로 상속받게끔 되어있다.

```
public class Animal extends Object {
    String name;

```

따라서 자바에서 만드는 모든 객체는 Object 자료형으로 사용할 수 있다.

```
Object animal = new Animal;
Object cat = new Cat;
```

다중상속이 안됨 -> 추상화 인터페이스 를 이용



유효범위 scope 

메소드 안에서 선언되면 그 메소드 안에서만 유효함. 

 static : 정적변수 메모리공간에 올라갈때 바로 사용할 수 있도록

메모리에 올리는 영역에 대한..

#### class밑에 있는 변수 직속 변수 : 전역변수

```
package myjava;
public class ScopeDemo3 {
    static int i=0; //i는 클래스의 변수, 실행되는 순간 사용 가능 
     
    static void a() {
      i=0; // 클래스 메소드에 0을 넣어주는 것
    } 
 
    public static void main(String[] args) { //바로 사용가능
        for (i = 0; i < 5; i++) {
            a(); // a메소드를 호출 
            System.out.println(i);
        }
    }// i에 계속 0을 넣어줘서 무한루프
 
}
```



(int 가 없으면 선언하지 않은것)

전역변수로 선언하면 클래스 내에서 다 사용가능

선언하지 않고 할당만 함



```
package myjava;
public class ScopeDemo3 {
    static int i=0; //i는 클래스의 변수
     
    static void a() {
       int i=0; //선언을 해줌으로서 메소드 안에서i 가 0 이라는 것
    }
 
    public static void main(String[] args) {
        for (i = 0; i < 5; i++) {
            a(); // a메소드를 호출 
            System.out.println(i);
        }
    }
 
}
```

```
package myjava;
public class ScopeDemo3 {
    static int i=0; //i는 클래스의 변수
     
    static void a() {
        i=0; // int 가 없으면 다시 선언하지 않은 것. 여기서는 다시 선언함
    }
 
    public static void main(String[] args) {
        for (int i = 0; i < 5; i++) { // for문안에서 변수를 선언해줘도됨
            a(); // a메소드를 호출 
            System.out.println(i);
        }
    }
 
}
```



#### 메소드 내부에서 선언된 변수: 지역변수



같은 변수더라도 메소드안에서 선언하면 다른것이다. 

무조건 밖에서 선언한다고 해서 같은게 아님 안에서 또 선언 할 수 있다.

for문 안에 선언하면 for 문 안에서만 사용가능!

부모는 자식의 변수를 사용할 수 없음.



정적인유효범위 static scope / lexical scope

메소드를 누가 호출했는지는 상관이 없다.



동적인 유효범위 dynamic scope

인스턴스 , this 의 의미

this : 인스턴스 자체를의미한다. 전역의 의미를 갖게된다



```
package myjava;
   
public class ScopeDemo4 {
    static String title = "";
    static void a(){
         int title = "coding everybody"; //확인용 
         System.out.println(title);
                
    }
    public static void main(String[] args) {
        a();
        System.out.println(title);
    }// 지역변수로만 넣어줘서 메소드안에서만 값이 출력
 
}
```

coding everybody



```
package myjava;
   
public class ScopeDemo4 {
    static String title = "";
    static void a(){
         title = "coding everybody";
                System.out.println(title);
                
    }
    public static void main(String[] args) {
        a();
        System.out.println(title);
    }
 
}// 원래 선언된값에다가 넣어줘서 두번 출력
```

coding everybody

coding everybody





#### this  

그 클래스 자체를 나타내는 전역변수  

클래스의 변수, 메서드를 사용하고 싶을때 사용

```

```

```
class C2 {
    int v = 10;
 
    void m() {
        int v = 20;
        System.out.println(v);
    }
}
 
public class ScopeDemo8 {
 
    public static void main(String[] args) {
        C2 c1 = new C2();
        c1.m();
    }
 
} //20을 출력
```

```
class C3 {
    int v = 10;
 
    void m() {
        int v = 20;
        System.out.println(this.v);
    }
}
 
public class ScopeDemo9 {
 
    public static void main(String[] args) {
        C3 c1 = new C3();
        c1.m();
    }
 
}this 는 해당 클래스를 나타냄 10 출력
```





# 초기화



이전의 메소드를 호출해서 넣어주는 방법

```
Calculator c1 = new Calculator();
c1.setOprands(10, 20); // 객체를 생성하고 
값을 넣어주는 메소드를 호출해서 넣어줌.
c1.sum();       
c1.avg();   
```

->호출하여 넣어주는 과정을 하기 전에 sum 과 avg를 호출한다면 원하는 값을 얻지 못함

-> 불편, 오류



#### 생성자

클래스명과 동일하고 리턴 자료형이 없는 메소드 를 생성자 라고 한다.

변수명은 꼭 의미있게. 중복을 써야하는 경우가 있기 때문에 this 주로 씀

```
class Calculator {
    int left, right;
 
    public Calculator(int left, int right) {
        this.left = left; // 지역변수를 전역변수에 바로 넣어주기
        this.right = right;
    }
 
    public void sum() {
        System.out.println(this.left + this.right);
    }
 
    public void avg() {
        System.out.println((this.left + this.right) / 2);
    }
}
 
public class CalculatorDemo1 {
 
    public static void main(String[] args) {
 
        Calculator c1 = new Calculator(10, 20); //선언과 동시에 값을 넣을 수 있다.
        c1.sum();
        c1.avg();
 
        Calculator c2 = new Calculator(20, 40);
        c2.sum();
        c2.avg();
    }
 
}
```

```
public void(int a, int b) {
left = a;
right= b;
}
//로 할 수 있음. 즉 변수가 겹쳐지는 경우에서 지역변수를 먼저 선택하기때문에 그걸 막기위해 변수를 바꿔준다면 가능
```

//적당한 단위로 객체를 쪼개는 것도 중요. 전역변수 많이 사용하는 것은 좋지 않다.

매개변수를 사용하는 것이 공식적인 방법

값을 사용자가 직접 바꾸는 것은 옳지않음. 메소드를 이용해야함. 오류확인. 외부 접근 제한



인스턴스가 생성될 때 인자 값을 넣어달라고 강제한다면 사용자가 값을 잊지않고 넣도록 도울 수 있다.





- 생성자의 특징

  값을 반환하지 않는다. 인스턴스 생성을 해주는 특수한 메소드.

  생성자의 이름은 클래스의 이름과 동일하다.



# static

모든 메소드, 변수 등은 무조건 메모리에 올라가야만 사용할 수 있다. 메모리에 올라가 있지 않다면 사용할 수 없다.

프로그램이 로딩되면서 먼저 static영역에 올려줌

정적 static메소드는 객체 생성 전에 메모리에 호출되는 메소드,

 정적 static변수 또한 객체 생성 전에 호출 됨



보통의 메소드는 객체가 생성되어야만 메모리에 올릴 수 있다. 즉, 메인에 호출할 수 있다.

 static을 씀으로서 객체가 생성되지 않아도 사용할 수 있도록 하기위함



인스턴스 변수도 마찬가지. 객체가 생성이 되지 않아 메모리에 올라가지 않은 상태라면 사용불가. 하지만 static 을 써줌으로서 사용가능



정적 변수는 모든 객체가 공유하는 정보를 나타낼때 주로 쓰인다.

ex) 상수 변수 final 을 사용해서 고정시켜줄 수 있다. 다시 입력 시 오류남





정적메소드는 this를 사용할 수 없다. 참조할 인스턴스 변수가 아직 메모리에 올라가지 않은 상태이기 때문이다. 

static 메소드에서 static변수가 사용 가능한지



#### 상속과 생성자

-------------------------

부모클래스와 자식클래스의 관계

자식클래스 extends 부모클래스

->부모클래스 ⊆ 자식클래스, 자식클래스는 부모클래스 타입

```
package myjava;
class Calculator111 {
    int left, right;
 
    public Calculator111(int i, int j) {
        // TODO Auto-generated constructor stub
    }

    public Calculator111() {
        // TODO Auto-generated constructor stub
    }

    public void setOprands(int left, int right) {
        this.left = left;
        this.right = right;
    }
 
    public void sum() {
        System.out.println(this.left + this.right);
    }
 
    public void avg() {
        System.out.println((this.left + this.right) / 2);
    }
}
 
class SubstractionableCalculator111 extends Calculator111{
    
    public SubstractionableCalculator111(int left, int right) {
        this.left = left;  
        this.right = right;
    }
 
    public SubstractionableCalculator111() {
        // TODO Auto-generated constructor stub
    }

    public void substract() {
        System.out.println(this.left - this.right);
    }
}
 
public class CalculatorConstructorDemo4 {
    public static void main(String[] args) {
        SubstractionableCalculator111 c1 = new SubstractionableCalculator111(10, 20); // 자식 개체 생성
        Calculator111 c2 = new Calculator111(); // 부모 개체를 생성
        Calculator111 c5 = new SubstractionableCalculator111(); // 자식 객체는 부모 클래스의 자료형인 것처럼 사용 가능 
        SubstractionableCalculator111 c5 = new Caculator111(); //부모 객체를 자식 클래스의 자료형인 것처럼 사용 불가능 ->오류
        Calculator111 c3 = c1; //부모클래스에 자식클래스를 넣을 수 있다. 하지만 이때 자식이 갖고 있는 메소드를 사용하지 못하게 됨
        
         
        c1.substract(); // 가능
        c3.substract(); // 불가능 자식식클래스의 메소드는 사용할 수 없다. 
        
        //c1.substract();
    }
}
```



#### 생성자 



1. 객체를 선언해줌.  자동으로 기본 생성자가 생김

```
public class ConstructorDemo {
    public static void main(String[] args) {
        ConstructorDemo  c = new ConstructorDemo();
    }
} /
```



2.오류 / 객체를 선언해줌 . 기본  생성자가 생기지 않음 매개변수를 넣어야하는 생성자가 있기 때문

```
public class ConstructorDemo {
    public ConstructorDemo(int param1) {}
    public static void main(String[] args) {
        ConstructorDemo  c = new ConstructorDemo();
    }// 존재하지 않는 생성자를 호출하고 있다. 
}
```

3. 인자가 없는 기본 생성자를 명시적으로 선언해주어야한다.

```
public class ConstructorDemo{


	public ConstructorDemo(){} //인자가 없는 기본 생성자를 만들어주면 에러 발생 x
	public ConstructorDemo(int param1){}// 매개변수가 있는 생성자가 있을 때는 자동으로 생성자를 만들어주지 않는다. 존재하지 않는 생성자를 호출하고 있다.
	
	public static void main(String[] args){
		ConstructorDemo c = new ConstructorDemo();// 기본생성자에 접근. 기본생성자가 안생겼기 때문에 직접 만들어 줌

}
	}
}
```



#### 



(정상코드)

```
class Calculator {
    int left, right;
 
    public void setOprands(int left, int right) {
        this.left = left;
        this.right = right;
    }
 
    public void sum() {
        System.out.println(this.left + this.right);
    }
 
    public void avg() {
        System.out.println((this.left + this.right) / 2);
    }
}
 
class SubstractionableCalculator extends Calculator {
    public SubstractionableCalculator(int left, int right) {
        this.left = left;  
        this.right = right;
    }
 
    public void substract() {
        System.out.println(this.left - this.right);
    }
}
 
public class CalculatorConstructorDemo4 {
    public static void main(String[] args) {
        SubstractionableCalculator c1 = new SubstractionableCalculator(10, 20);
        c1.sum();
        c1.avg();
        c1.substract();
    }
}
```



-> 매개변수 두개를 받는 생성자를 추가하면 오류가 난다.

```
class Calculator {
    int left, right;
     
    public Calculator(int left, int right){
        this.left = left;// 생성자를 이미 명시적으로 표시.
        //기본생성자가 없어서부모 클래스가 정의되어 있지않다.
        //자바는 기본생성자를 만들어주지 않음
        this.right = right;
    }
     
    public void setOprands(int left, int right) {
        this.left = left;
        this.right = right;
    }
 
    public void sum() {
        System.out.println(this.left + this.right);
    }
 
    public void avg() {
        System.out.println((this.left + this.right) / 2);
    }
}
 
class SubstractionableCalculator extends Calculator {
    public SubstractionableCalculator(int left, int right) {
        this.left = left;
        this.right = right;
    }
 
    public void substract() {
        System.out.println(this.left - this.right);
    }
}
 
public class CalculatorConstructorDemo5 {
    public static void main(String[] args) {
        SubstractionableCalculator c1 = new SubstractionableCalculator(10, 20); 인스턴스 화 시키면 호출하기전에 부모 클래스의 생성자를 자동으로 호출하도록 약속되어있다. 근데 부모클래스를 보면 기본 생성자가 존재하지 않는다. -> 명시적으로 선언해라.
        c1.sum();
        c1.avg();
        c1.substract();
    }
}
```



하위 클래스를 호출시키면 자동으로 상위 클래스의 기본 생성자를 호출하게 된다. 상위 클래스에 생성자가 없을 경우 존재하지 않는 생성자가 호출되므로 에러가난다. 

-> 부모 클래스에 기본 생성자 생성함으로서 해결

```
class Calculator {
    int left, right;
    
    public Caculator(){} //기본 생성자를 넣어줌
     
    public Calculator(int left, int right){
        this.left = left;  
        this.right = right;
    }
     
    public void setOprands(int left, int right) {
        this.left = left;
        this.right = right;
    }
 
    public void sum() {
        System.out.println(this.left + this.right);
    }
 
    public void avg() {
        System.out.println((this.left + this.right) / 2);
    }
}
 
class SubstractionableCalculator extends Calculator {
    public SubstractionableCalculator(int left, int right) {
        this.left = left;     
        this.right = right;
    }
 
    public void substract() {
        System.out.println(this.left - this.right);
    }
}
 
public class CalculatorConstructorDemo5 {
    public static void main(String[] args) {
        SubstractionableCalculator c1 = new SubstractionableCalculator(10, 20);
        c1.sum();
        c1.avg();
        c1.substract();
    }
}
```



중복이 발생. 코드가 많아지고 유지보수가 어려워짐 

```
class Calculator {
    int left, right;
    
    public Caculator(){}
    
    public Calculator(int left, int right){
        this.left = left;
        this.right = right;
    }
     
    public void setOprands(int left, int right) {
        this.left = left;
        this.right = right;
    }
 
    public void sum() {
        System.out.println(this.left + this.right);
    }
 
    public void avg() {
        System.out.println((this.left + this.right) / 2);
    }
}
 
class SubstractionableCalculator extends Calculator {
    public SubstractionableCalculator(int left, int right) {
        this.left = left;
        this.right = right;//생성자   -> 중복이 있으면 코드가 많아지고 유지보수어려워짐 -> 중복을 없애기 위해 Super 사용.
    }
 
    public void substract() {
        System.out.println(this.left - this.right);
    }
}
 
public class CalculatorConstructorDemo5 {
    public static void main(String[] args) {
        SubstractionableCalculator c1 = new SubstractionableCalculator(10, 20);
        c1.sum();
        c1.avg();
        c1.substract();
    }
}
```





상위 하위가 동일한 생성자를 갖고 있다. 동일한 일을 하고 있다? -> 중복 여러가지 문제가 생김

//하위 클래스에서 상위 클래스의 생성자와 같은 역할을 하는 생성자가 필요한데.. 이걸 또 넣어주지 않고 하는  방법이 있다.

# super

상위 클래스를 가리키는 키워드



생성자가 같다면 중복이 생김.-> 해결

```
package myjava;
class Calculatorr {
    int left, right;
    
    
    public Calculatorr(int left, int right){// 정수 두개를 받는 이 생성자가 호출
        this.left = left;
        this.right = right; 
    }
    
    
    public void setOprands(int left, int right){
        this.left = left;
        this.right = right;
    }
    
    
    public void sum(){
        System.out.println(this.left+ this.right);
    }
    
    public void avg(){
        System.out.println((this.left+this.right)/2);
    
    }
}

class Substraction extends Calculatorr{
    public Substraction(int left, int right){
        super(left, right);
    } //매개변수의 값이 슈퍼 클래스의 안으로 들어감
    //상위 클래스의 생성자를 하위 클래스에서 호출해서 실행할 수 있게해준다.
    //this가 자기자신 이였다면 super는 부모
    public void substract(){
        System.out.println(this.left - this.right);
        
    }
}

    public class CalculatorConstructorDemo5{
        public static void main(String[] args){
            Substraction c1 = new Substraction(10,20);// 전달 해줌
            c1.sum();
            c1.avg();
            c1.substract();
        }
    } 
```

결론 부모의 기본 생성자를 우선 호출해주어야 함 . 내가 작업해놓은 생성자를 명시적으로 호출시켜줌으로서 기본 생성자를 호출하지 않아도 되게 해줌

상속을 받은 자식 클래스는 생성하자마자 부모의 클래스의 생성자를호출하도록 되어있다. 이 때 부모클래스의 생성자에 매개변수가 존재한다면 그것을해결할 방법 두가지

1. 부모의 생성자에 기본 생성자를 생성.

2. 자식 클래스의 생성자안의 부모클래스의 매개변수 생성자인 super(매개변수); 선언

   주의점 : super(매개변수);는 자식 클래스의 생성자 안에서 가장 처음 존재해야한다.....





# 오버라이딩

창의적인 상속, 재 정의하는 것, 

기존의 부모의 메소드를 덮어쓰기를 통해 기능을 변경한 자식만의 메소드

부모 클래스의 메소드기능에 새로운 기능을 덮어쓰기 해서 독자적 정의를하는 것

부모와 자식에 같은 이름의 메소드가 있다면 자식 클래스의 메소드가 실행된다.

```
package org.opentutorials.javatutorials.overriding.example1;
 
class Calculator {
    int left, right;
 
    public void setOprands(int left, int right) {
        this.left = left;
        this.right = right;
    }
 
    public void sum() {
        System.out.println(this.left + this.right);
    }
 
    public void avg() {
        System.out.println((this.left + this.right) / 2);
    }
}
 
class SubstractionableCalculator extends Calculator {
     
    public void sum() {
        System.out.println("실행 결과는 " +(this.left + this.right)+"입니다.");
    }// 부모가 이미 갖고 있는 메소드를 재 정의
     
    public void substract() {
        System.out.println(this.left - this.right);
    }
}
 
public class CalculatorDemo {
    public static void main(String[] args) {
        SubstractionableCalculator c1 = new SubstractionableCalculator();
        c1.setOprands(10, 20);
        c1.sum();
        c1.avg();
        c1.substract();
    }
}
```

실행 결과는 30 입니다.

15

-10



![image-20200728125837401](C:\Users\rey\AppData\Roaming\Typora\typora-user-images\image-20200728125837401.png)

부모 클래스에서 sum 정의 : 모든 클래스 들의 기본적인 동작방법 정의 공통분모 정의 / 넓게

하위 메소드에서 sum 정의 : 부모 클래스의 sum보다 더 높은 우선순위.  /우선 순위





출력하는 메소드를 리턴해주는 메소드로 오버라이딩 하면?

```
class Calculator {
    int left, right;
 
    public void setOprands(int left, int right) {
        this.left = left;
        this.right = right;
    }
 
    public void sum() {
        System.out.println(this.left + this.right);
    }
 
    public void avg() {
        System.out.println((this.left + this.right) / 2); //평균 값 출력
    }
}
 
class SubstractionableCalculator extends Calculator {
     
    public void sum() {
        System.out.println("실행 결과는 " +(this.left + this.right)+"입니다.");
    }
     
    public int avg() {
        return (this.left + this.right)/2; // int 값 리턴
    }
     
    public void substract() {
        System.out.println(this.left - this.right);
    }
}
 
public class CalculatorDemo {
    public static void main(String[] args) {
        SubstractionableCalculator c1 = new SubstractionableCalculator();
        c1.setOprands(10, 20);
        c1.sum();
        c1.avg();
        c1.substract();
    }
}
```

-> 하위 클래스의 메소드의 리턴 타입이 부모 클래스의 리턴타입과 호완되지 않아 오류

-> 리턴값이 불일치 하는 경우 안됨 



주의점 : 

-> 메소드의 이름, 리턴형, 메소드의 매개변수의 갯수, 데이터 타입, 그리고 순서, 메소드의 리턴타입

:= 메소드의 서명 시그니처가 일치해야한다.





해결?

부모의 메소드를 자식 메소드와 같게 고쳐주기... 

```
 
class Calculator {
    int left, right;
 
    public void setOprands(int left, int right) {
        this.left = left;
        this.right = right;
    }
 
    public void sum() {
        System.out.println(this.left + this.right);
    }
 
    public int avg() { // 자식 클래스의 메소드와 같게 고쳐주기
        return (this.left + this.right) / 2;
}
 
class SubstractionableCalculator extends Calculator {
     
    public void sum() {
        System.out.println("실행 결과는 " +(this.left + this.right)+"입니다.");
    }
     
    public int avg() {
        return (this.left + this.right)/2;
    }
     
    public void substract() {
        System.out.println(this.left - this.right);
    }
}
 
public class CalculatorDemo {
    public static void main(String[] args) {
        SubstractionableCalculator c1 = new SubstractionableCalculator();
        c1.setOprands(10, 20);
        c1.sum();
        c1.avg();
        c1.substract();
    }
}
```



하지만 부모의 수정 없이 상속받는 것이 목적이기 때문에 좋은 방법은 아님, 중복 도 생김 -> 유지보수, 가독성 낮아짐..

코드의 중복은 최대한 제거해야하는 존재



-> super를 써서 해결하기 

```
class Calculator {
    int left, right;
 
    public void setOprands(int left, int right) {
        this.left = left;
        this.right = right;
    }
 
    public void sum() {
        System.out.println(this.left + this.right);
    }
 
    public int avg() {
        return ((this.left + this.right) / 2);
    }
}
 
class SubstractionableCalculator extends Calculator {
     
    public void sum() {
        System.out.println("실행 결과는 " +(this.left + this.right)+"입니다.");
    }
     
    public int avg() {
        return super.avg(); // 상위 클래스의 메소드를 호출하기 위해 super를 썼다.
    }
     
    public void substract() {
        System.out.println(this.left - this.right);
    }
}
 
public class CalculatorDemo {
    public static void main(String[] args) {
        SubstractionableCalculator c1 = new SubstractionableCalculator();
        c1.setOprands(10, 20);
        c1.sum();
        System.out.println("실행 결과는" + c1.avg());
        c1.substract();
    }
}
```

실행 결과는 30입니다.
실행 결과는15
-10

```
public int avg(){
	return super.avg(); //부모의 메소드를 호출
}//뒤에 더 추가해도 됨 
```



# overloading

같은 이름이지만 서로다른 매개변수의 형식을 갖고 있는 메소드를 여러개를 정의 하기 위한 방법

사용자는 별도로 기억할 필요 없이 하나의 이름의 메소드에 값을 갯수에 상관 없이 넣을 수 있음

```
c1.setOprands3(10,20,30);
c1.setOprands2(10,20);
```

//둘 다 값을입력 받는 메소드 이지만 매개변수를 3개 받아야하는 메소드에서 두개를받거나 그 반대의 경우 오류가 난다. 

-> 다른 이름으로 다 지정해주어야 한다.

똑같은 동작방법을 갖고 있지만 매개변수가 달라지는 이유로 인해 달라져야 한다.

한가지 이름의 메소드에 매개변수 갯수를 다르게하여 넣는 방법이 있을까 ,



해결? 오버로딩

```
 
class Calculator{
    int left, right;
    int third = 0; //새로지정 두개의 값만 들어갔을 때는 0이 되게..
      
    public void setOprands(int left, int right){
        System.out.println("setOprands(int left, int right)");
        this.left = left;
        this.right = right;
    }
     
    public void setOprands(int left, int right, int third){
        System.out.println("setOprands(int left, int right, int third)");
        this.left = left;
        this.right = right;
        this.third = third;
    }
     
    public void sum(){
        System.out.println(this.left+this.right+this.third);
    }
      
    public void avg(){
    	
        System.out.println((this.left+this.right+this.third)/3);
    }
}
  
public class CalculatorDemo {
      
    public static void main(String[] args) {
          
        Calculator c1 = new Calculator();
        c1.setOprands(10, 20);
        c1.sum();       
        c1.avg();
        c1.setOprands(10, 20, 30);
        c1.sum();       
        c1.avg();
         
    }
  
}
```

같은 이름 ( 다른 매개변수)

자바에선 이름이 같더라도 매개변수의 형식, 갯수가 다르다면 다른 메소드로 인식한다

-> 이름을 다 다르게 지정해줘야하는 수고로움이 사라짐, 사용자 입장에서도 혼동 없이 사용가능

하지만 중복이 생김



-> 중복이 되는 코드를

```
 
class Calculator{
    int left, right;
    int third = 0;
      
    public void setOprands(int left, int right){
        System.out.println("setOprands(int left, int right)");
        this.left = left;
        this.right = right;
    }
     
    public void setOprands(int left, int right, int third){
        System.out.println("setOprands(int left, int right, int third)");
        this.setOprands(left,right)// 중복이되는 메소드를 먼저 호출해서 중복제거
        this.third = third;//추가로 필요한 부분만 부가->재활용,중복제거.유지보수편의성
    }
     
    public void sum(){
        System.out.println(this.left+this.right+this.third);
    }
      
    public void avg(){
        System.out.println((this.left+this.right+this.third)/3);
    }
}
  
public class CalculatorDemo {
      
    public static void main(String[] args) {
          
        Calculator c1 = new Calculator();
        c1.setOprands(10, 20);
        c1.sum();       
        c1.avg();
        c1.setOprands(10, 20, 30);
        c1.sum();       
        c1.avg();
         
    }
  
}
```



같은 매개변수(갯수, 타입)를 갖고 있는 메소드가 리턴값이 다르면 오버로딩이 아니라 오류

매개변수가 존재하지 않는 두개의 메소드도 리턴값이 다르면 오류 있을때



자바는 누구를 호출 한 것인지 모름. 리턴값을 뭘 원하는지 모름



오버로딩 : 같은 이름.  다른 메소드

오버라이딩 : 부모클래스의 메소드의 이름과 매개변수 형식 갯수가 동일한 메소드를 다시 재정의



오버라이딩 : 부모 클래스의 메소드와 이름, 변수 갯수, 타입, 리턴 값의 타입

오버로딩 :  메소드 끼리 이름, 리턴값의 타입이 같아야 하고 매개변수의 표현형, 갯수는 상관 없다.

(매개변수의 이름은 상관없음)

반환값은 메소드를 사용한 결과 -> 에러를 발생



# 클래스 패스

>  클래스가 위치하는 경로를 지정하여 자바가 필요로 하는 클래스를 로드해줌

my.java

```
class Item{
}
 
class ClasspathDemo {
} 
```



>  터미널에서 cd로 현재 디렉토리로 이동 후
>
> dir로 파일 목록확인
>
> javac my.java 로 컴파일
>
> 확장자가 class인 ITem, ClasspathDemo파일이 생성된다. 

 

-> 소스코드 안에 클래스 갯수만큼 클래스 파일이 만들어짐. 

* 이 클래스 파일들은 그 클래스와 관계된 파일이 컴파일 될 때 사용되야 한다.

* 사용되는 클래스들이 모두 같은 디렉터리 안에 있어야 오류 안남

* 다른 곳에 있다면  누락된 클래스가 위치하고 있는 곳을 클래스 패스로 알려줌



 ```java -classpath".;lib" Classpathdemo2 ```

* ;  경로와 경로를 구분해주는 구분자

* .  현재 디렉터리 에서 클래스를 찾는다

  -> 현재 디렉토리를 먼저 찾아보고 없다면 그 밑에있는 립 디렉토리에서 찾아봐라

```java -classpath"lib" Classpathdemo2```

lib안에서만 찾아봐라./ 기본 클래스를 찾을 수 없다.

립 디렉토리에서만 찾아봐라



#### 환경변수

>  운영체제에 지정하는 변수 / 어디에 있건 간에 접근할 수 있는 변수



* 컴파일을 할 때마다 클래스 패스를 지정하는 것은 번거롭다 -> 환경변수를 이용

* 자바 가상머신과 같은 어플리케이션 들은 환경변수의 값을 참고해서 동작

* 자바는 클래스 패스로 환경변수 CLASSPATH를 사용하는데 이 값을 지정하면 실행할 때 마다

  -classpath 옵션을 사용하지 않아도 되기 때문에 편리하다. 하지만 운영체제를 변경하면 클래스패스가사라지기 때문에 이식성면에서 불리할 수 있음







# 패키지

> 자바 패키지는 자바 클래스 들을 여러 이름공간으로 정리. 
>
> (- 어떤 이름(변수,함수,메소드 등)으로 영향을 미칠 수 있는 공간(범위))
>
> 하나의 클래스 안에서 같은 이름의 클래스를 사용하기 위한 방법
>
> 다른 디렉터리에 저장한다면 하나의 컴퓨터 안에 같은 이름의 파일이 공존 할 수 있다 .



패키지 명은 보통 그 폴더의 경로

같은 패키지가 아니면 로드할 수 없다. -> import 다른 패키지의 클래스를 가져온다

```
package java.awt.event;
```

* import 패키지명.*  : 패키지 안의 모든 클래스를 가져올 수 있다. -> 오류가 날 수도 있음

* import 패키지명.클래스  : 패키지안의 클래스를 가져온다

다른 패캐지의 클래스는불가 -> import

(scr : 소스코드가 들어있는 디렉터리, bin : 클래스 컴퓨터가 이핼 것들이 들어가있는 디렉터리)





그럼 다른 패키지 안의 같은 이름의 파일들을 구분하는 법은?

```
package org.opentutorials.javatutorials.packages.example3;
import org.opentutorials.javatutorials.packages.example1.*;
import org.opentutorials.javatutorials.packages.example2.*;
 
public class D {
    public static void main(String[] args) {
        org.opentutorials.javatutorials.packages.example2.B b = new org.opentutorials.javatutorials.packages.example2.B();
    }
}
// 패키지명.클래스명을 해주면 특정 패키지에 있는 클래스를 나타낼 수 있음
  
```









# api, api 문서 보는법

```
System.out.println(1);
```

>  println은 PrintSteam 이라는 클래스의 메소드 이다.  하지만 이를 System 클래스에서 쓰기 위해서 out이라는 변수를 생성하여 사용했다.  PrintStream out = new PrintStream();

* println(1) : 괄호안의 정보를 출력하는 메소드

* System : 클래스, 대문자로 시작해야하는 네이밍 규칙

* out : 시스템 클래스의 맴버 중 하나인 변수. 이 변수는 프린트 메소드를 갖고 있는 객체



-> System의 소속이 아니라 out이라는 객체가 갖고 있는 메소드

>  System.out을 쓸 때 System 클래스에서 인스턴스화 시키지 않았다. 
>
> 이는 out 이 System클래스의 클래스 변수(static)이라는 것을 알 수 있다.



http://docs.oracle.com/javase/

java.lang 패키지의 System 클래스 / 클래스 맴버 확인 가능

fields 

err, in, out 필드의 이름 정적 변수/ 

printStream 그 변수의 데이터 타입 , 변수에 담겨져 있는 것 printStream 이라는 클래스

printSteam 클래스의 메소드 기능들을 확인 할 수 있다.

매개변수에 따라 다른 작용을하는 같은 이름의 메소드 들 ( 오버로딩 )



### API

application programming interface

시스템과 시스템을 제어하는 주최 사이의 접점에 해당하는 조작방법

어떻게 출력기능을 구현하는지는 모르지만 명령을 통해 그 기능을 사용할 수 있다.

우리가 프로그램을만들때 쓰는 코드의 형태를 띄고 있는 인터페이스

### UI

UI user interface

중계자.  접점. 입력장치, 출력장치 등 시스템이 사용자를 대면하는 접점 

사용자의 의중을 시스템에 전달,  시스템의 상태를 사용자에게 보여준다.



api 문서 보는 법

자신이 필요한 기능을 찾는 법

api documentation



# 접근 제어자

> **권한**에 차등을 두는 것. 협업을 하게 되었을 때 자유만 있다면 여러 문제가 생길 수 있다.
>
> -> 규제를 둠
>
> 변수의 데이터 타입이나, 리턴타입이나.. 등등 
>
> 추상클래스, final, 접근 제어자, 인터페이스 등등  자바는 객체지향 언어기때문에 더 중요
>
> 더 문제없이. 자유롭게 프로그래밍 하기 위한 것임.



* public  누구든 그 클래스의 메소드를 사용할 수 있다.

* private 이면 클래스 내부에서만 사용가능하다. 외부에서 사용하라하면 오류



```

class A {
    public String y(){
        return "public void y()";
    }
    private String z(){
        return "public void z()";
    }
    public String x(){
        return z();
    }
}
public class AccessDemo1 {
    public static void main(String[] args) {
        A a = new A();
        System.out.println(a.y());
        // 아래 코드는 오류가 발생한다.
        //System.out.println(a.z());
        System.out.println(a.x()); //x 메소드가 호출되고 내부적으로 메소드 z를 호출하고 있기 때문에 메소드 z는 정상적으로 호출된다. 왜냐면 메소드 x와 z는 같은 클래스 소속이기때문
    }
}
```

>  은행으로 비유하면  고객 :  AccessDemo1, public : 창구 x, private : 금고 z 

-> 사용자는 사용하도록 의도되어있는 것들만을 사용하게 된다.



|                             | public | protected | default  | private  |
| --------------------------- | ------ | --------- | -------- | -------- |
| 같은 패키지, 같은 클래스    | 허용   | 허용      | 허용     | 허용     |
| 같은 패키지, 상속 관계      | 허용   | 허용      | 허용     | **불용** |
| 같은 패키지, 상속 관계 아님 | 허용   | 허용      | 허용     | **불용** |
| 다른 패키지, 상속 관계      | 허용   | 허용      | **불용** | **불용** |
| 다른 패키지, 상속 관계 아님 | 허용   | **불용**  | **불용** | **불용** |

![img](https://s3.ap-northeast-2.amazonaws.com/opentutorials-user-file/module/516/1996.jpg)

>  protected 는 다른 패키지라도 상속받으면 접근 가능



#### 클래스의 접근 제어자

* public : 다른 패키지의 클래스에서도 사용 가능

* default : 같은 패키지 에서만 사용 가능 (아무것도 안붙히는거랑 같음)



```
package org.opentutorials.javatutorials.accessmodifier.inner;
public class PublicClass {}
```

> inner 로 끝나는 패키지에 public형으로 지정되어있다.



```
package org.opentutorials.javatutorials.accessmodifier.inner;
class DefaultClass {}
```

> inner 로 끝나는 패키지에 default형으로 지정되어 있다. 

```
package org.opentutorials.javatutorials.accessmodifier.inner;
public class ClassAccessModifierInnerPackage {
    PublicClass publicClass = new PublicClass();
    DefaultClass defaultClass = new DefaultClass();
} // 둘다 inner 안에 있는 클래스 이므로 사용 가능
```

```
package org.opentutorials.javatutorials.accessmodifier.outter;
import org.opentutorials.javatutorials.accessmodifier.inner.*;
public class ClassAccessModifierOuterPackage {
    PublicClass publicClass = new PublicClass();
    //DefaultClass defaultClass = new DefaultClass();
} 같은 패키지의 클래스에서만 사용이 가능하기 때문
```



public 을 쓸때 제약사항

* 반드시 소스코드의 이름은 퍼블릭 클래스의 이름하고 동일해야한다.
* 하나의 소스코드안에는 public 클래스가 하나만 존재해아한다.



# Abstract

> 상속을 강제하는 일종의 규제, 추상메소드로 정의해줌

```
package org.opentutorials.javatutorials.abstractclass.example1;
abstract class A{ //A는 추상클래스 반드시 상속해서 사용해야함
    public abstract int b(); // {}가 없고 시그니쳐만 있음 -> 반드시 다시 정의해줘야함
    //본체가 있는 메소드는 abstract 키워드를 가질 수 없다.
    //public abstract int c(){System.out.println("Hello")}
    //추상 클래스 내에는 추상 메소드가 아닌 메소드가 존재 할 수 있다. 
    public void d(){
        System.out.println("world");
    }
}
class B extends A{
	public int b(){ // 추상 메소드였던 b()를 사용해주기 위해 본체를 정의해줌
		return 1; 
	}

}
public class AbstractDemo {
    public static void main(String[] args) {
        A obj = new A();
        B odj = bew B();
    }
}
```

> 부모클래스에서 추상 메소드는 본체가 없고 시그니쳐만 있음 . 
>
> 이 메소드를 사용해주기 위해선 상속받은 하위 클래스에서 본체를 다시 정의해주는 과정이 필요하다. 구현의 책임을 사용하는 대상에게 넘기는 것



* 담고 있는 메소드 중 하나라도 abstract 면 자동으로 클래스도 abstract가 된다.
* 추상 클래스에는 추상 메소드가 아닌 메소드가 존재할 수 있다



#### 추상 클래스를 사용하는 이유

상속을 강제하기 위한 규제. 

공통적인 기능이 아닌 상황에 따라 동작하는 방법이 달라져야 하는 부분을 사용자에게 위임

```
package org.opentutorials.javatutorials.abstractclass.example3;
abstract class Calculator{
    int left, right;
    public void setOprands(int left, int right){
        this.left = left;
        this.right = right;
    } 
    public abstract void sum();  //부모 클래스에서 sum, avg라는 추상 메소드를 만듬
    public abstract void avg();
    public void run(){ 
        sum();
        avg();
    }
}
class CalculatorDecoPlus extends Calculator {  //부모클래스를 상속
    public void sum(){ //추상메소드의 본체를 구체적으로 정의
        System.out.println("+ sum :"+(this.left+this.right));
    }
    public void avg(){
        System.out.println("+ avg :"+(this.left+this.right)/2);
    }
} 
class CalculatorDecoMinus extends Calculator { //부모클래스를 상속
    public void sum(){ //추상메소드의 본체를 구체적으로 정의
        System.out.println("- sum :"+(this.left+this.right));
    }
    public void avg(){
        System.out.println("- avg :"+(this.left+this.right)/2);
    }
} 
public class CalculatorDemo {
    public static void main(String[] args) { 
        CalculatorDecoPlus c1 = new CalculatorDecoPlus();
        c1.setOprands(10, 20);
        c1.run();
         
        CalculatorDecoMinus c2 = new CalculatorDecoMinus();
        c2.setOprands(10, 20);
        c2.run();
    }
   
}
```



중복되는 부분이 생김 -> 유지보수의 문제

```
package org.opentutorials.javatutorials.abstractclass.example3;
abstract class Calculator{
    int left, right;
    public void setOprands(int left, int right){
        this.left = left;
        this.right = right;
        
    }
    
    int _sum(){
    	return this.left+this.right; //공통된 부분을 메소드로 정의
    } 
    public abstract void sum();  
    public abstract void avg();
    public void run(){
        sum();
        avg();
    }
}
class CalculatorDecoPlus extends Calculator {
    public void sum(){
        System.out.println("+ sum :"+_sum());
    }
    public void avg(){
        System.out.println("+ avg :"+_sum()/2);
    }
} 
class CalculatorDecoMinus extends Calculator {
    public void sum(){
        System.out.println("- sum :"+(this.left+this.right));
    }
    public void avg(){
        System.out.println("- avg :"+(this.left+this.right)/2);
    }
} 
public class CalculatorDemo {
    public static void main(String[] args) { 
        CalculatorDecoPlus c1 = new CalculatorDecoPlus();
        c1.setOprands(10, 20);
        c1.run();
         
        CalculatorDecoMinus c2 = new CalculatorDecoMinus();
        c2.setOprands(10, 20);
        c2.run();
    }
   
}
```



# final

> 상속/ 변경을 금지하는 규제
>
> 절대 변하지 않는 특정한 것을 정하고 싶을 때

```
class Calculator {
    static final double PI = 3.14; // 변경 금지
    int left, right;
 
    public void setOprands(int left, int right) {
        this.left = left;
        this.right = right;
        //Calculator.PI = 6; // 변경하려고 하면 오류발생
    }
 
    public void sum() {
        System.out.println(this.left + this.right);
    }
 
    public void avg() {
        System.out.println((this.left + this.right) / 2);
    }
}
 
public class CalculatorDemo1 {
 
    public static void main(String[] args) {
 
        Calculator c1 = new Calculator();
        System.out.println(c1.PI);
        //Calculator.PI = 10;
 
 
    }
 
}
```

> 클래스 변수의 예를 들었지만 인스턴스 변수에도 적용된다.

final 메소드

```
 class A{
    final void b(){}
}
class B extends A{
    void b(){}   // final 메소드 b를 상속하려 하기 때문에 오류
}
```

final 클래스

```
final class C{
    final void b(){}
}
class D extends C{} // final 클래스를 상속하려고 하기때문에오류
```

->

- final 은 변수, 메소드 클래스에 모두 사용할 수 있다.
- 변수에 사용하면 변하지 않는 상수. 
- 메소드에 사용하면 상속, 재정의가 불가능한 메소드. 
- 클래스에 사용하면 상속이 불가능한 하나의 완전한 클래스



# 인터페이스

> 자바 프로그래밍 언어에서 클래스 들이 구현해야 하는 동작을 지정하는데 사용되는 추상 자료형.
>
> is a 관계가 성립하지 않거나 다중 상속을 하고 싶을 때 사용한다. 
>
> 인터페이스는 변수를 갖지 않는 클래스 이기 때문에 다중상속과 유사한 기능 구현 가능
>
> ( 자바는 다중상속이 불가 why? 동일한 이름의 변수가 중복되어 사용될 수도 있기 때문.)
>
> ex) 폴라로이드 카메라 : 프린터 클래스 + 카메라 클래스 -> 카메라 클래스는 상속받고 프린터라는 인터페이스를 사용



* how

  - 인터페이스의 상속 -> 자식 클래스를 생성 -> 자식 클래스의 객체를 생성 -> 프로그램을 사용

  - (인터페이스는 추상 메서드를 포함하고 있는 추상 클래스. 추상 메서드를 포함하고 있으면 객체 생성이 불가능하므로 자식클래스를 생성 -> 자식 클래스에서 객체를 생성하여 사용하기 때문에 유지 보수가 쉬움

  - 상수와 추상 메소드 외에 다른 맴버를 갖지 못하게 함으로서 더욱 더 추상화를 완벽하게함

  > 추상메소드 ? 함수의 원형은 있는데 그 함수로 뭘 처리해주겠다는 내용이 없는 것 {}X
  >
  > ```
  > public void kindOf(); //{}가 없음
  > ```
  >
  > 추상 메소드는 추상 클래스 내에서만 선언할 수 있다. 일반 클래스에서 추상 메소드를 선언할 수 없다. 추상 메소드가 하나라도 존재하는 클래스는 반드시 추상 클래스가 되어야 한다.
  >
  > 추상 클래스는 불완전한 추상 메소드를 포함한 불완전한 클래스 이므로 객체를 만들어 사용할 수 없다. 그래서 추상 클래스를 상속 받은 자식 클래스는 모든 추상 메소드를 override 해서 사용해야한다. 
  >
  > ```
  > abstract class Product {
  > 	
  > 
  > //	추상 메소드는 함수의 몸통인 "{}" 블록을 가지지 않는 메소드
  > //	추상 메소드는 abstract 예약어를 사용해 만들며 "{}" 블록이 없는 불완전한 메소드이다.
  > 	public abstract void kindOf();	// <-추상 메소드
  > 	
  > }
  > 
  > ```
  >
  > 추상 클래스와 메소드는 abstract로 표시되어야 한다. 하지만 인터페이스는 모든 메소드 들이 정의상 추상적이기 때문에 abstract 키워드가 필요하지 않다. 암묵적으로 public





+ 그럼 인터페이스는 추상 클래스 인가? 아니다

  추상 클래스는 내가 원하는 메소드를 추상 메소드로 선언할 수 있지만 

  인터페이스에서는 기본형 변수를 선언하거나, 메소드를 정의해버리면 오류가 난다.

  즉, 정적변수나 메소드의 선언만이 올 수 있음. ( 사실 abstract가  숨겨져 있긴 하지만 무조건 추상 메소드 이기 때문에 붙일 필요가 없다. )

* 인터페이스 정의

```
public interface 인터페이스명[extends 부모인터페이스명, ...]{
	// 상수     -> 일반 변수 못갖음. final 예약어를 이용해서 멤버 변수를 선언해야함
	           객체를 생성할 수 없으므로 static 예약어를 붙여 상수 선언
	           
	           -> 객체를 사용하지 않고 인터페이스 이름으로 직접 해당 상수를 사용하게 하				기 위해서는 static 과 final을 같이 써야함
	           -> 인터페이스 변수 선언에 
	// 추상 메서드  
}
```





* 상속 :  extends 대신 implements 예약어 사용 

``` 
[modifiers] class 클래스명 [extends 부모 클래스]
	implements [인터페이스1, 인터페이스2, ...]{

	}
```

