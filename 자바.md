## 200721

# 변수



자바는 다른 언어에 비해 자료형 선언 같은 것들이 엄격하다. 컴파일 단계에서 예상되는 문제점을 예측할 수 있다.  금융이나 과학적 계산처럼 엄격함이 요구되는 분야에 주로 사용

\를 " 앞에 위치시키면 단순히 문자로 해석하도록 할 수 있다.

실수형 변수 : double  8byte / float 4byte  부동소수점 근삿값으로 소수를 표현    mbyte  : 2^(m*8) 개의 숫자 가능 0중심

 ```
float a = 2.0F 
float a = (float)100.0
//정수가 아닌 실수값은 그 자체로 double 값이다. 그러므로 float에 저장하기 위해선 형변환을 해야한다.
long a = 2147483648L //int에 저장될 수 있는 최댓값을 넘었기 때문에
 ```

```
byte a = 100;
short b = 200; //이건 가능 int 허용하기 때문   
```



byte -> short char -> int -> long -> float -> double

자동형 변환은 작은 범위에서 넓은 데이터 타입으로의 변환만 허용이고 형변환을 따로 안해줘도 저절로 상수 값이 변환되어 변수에 저장되는 것이다.

명시적 형변환은 (데이터타입)데이터 값 형태로 직접 써서 변환 시켜주는 것이다. 이는 넓은 데이터에서 좁은 데이터로 바꾸는 데 쓰임 이는 데이터 손실이 일어나므로 버그를 없애기위해 사용



문자형 변수 : char 2byte

문자열 : string 글자들의 집합  2*글자수 byte

모든 객체는 힙 메모리에 위치한다. 힙메모리는 프로세스가 실행될 때 운영체계로 부터 할당, 자바는 자바 가상머신이 실행될 때 운영체계로 부터 힙메모리를 할당받는다. 힙메모리는 고정되어 있을 수도 가변적일 수도 있다. 초기힙, 최대 힙 메모리의 양을 설정할 수도 있다. 최대는 2GB! 따라서 string 클래스의 문자열의 최대 가능 길읻 2GB가 한계

```
java-Xms16s Xms128m Myclass
(초기값 16, 최대 힙 메모리 128)
```



-> string 클래스의 문자열 길이의 한계는 하드웨어 머신과 운영체계에서 허용하는 최대한의 크기까지 가능. 특별히 규약에서 제약하는 사항은 없다. 자바 가상 머신에 따라 힙 메모리 할당에 옵션 설정이 있을 수 있다.

 변수 두개 동시 선언 가능

alert?



# 연산자



정수 * 정수 - 정수

정수*실수 - 실수 로 형변환



boolean 참 거짓을 의미하는 데이터 타입

.equals 는 문자열을 비교할 때 사용하는 메소드 a.equals(b)



#### 산술 연산자

+, -, *, /, %, 

##### 증감 연산자 

++, --



#### 관계연산자 : 두수를 비교하여 참(1)거짓(0) 을 결과로 얻음

== 같다, != 같지않다, >, >=, <, <= 



#### 비트 연산자 : 이진법 0,1로 연산하여 결과를 얻는 연산자

& and  모든 비트가 1일때만 1 이더넷 주소 서브넷마스크 

^ xor  모든 비트가 같으면 0 하나라도 다르면 1

| or  모든비트 중 한비트라도 1이면 1

~ not 각 비트의 부정 0이면 1 1이면 0

```
a=5
b=7

a&b = 000...00000000...000000 0101
	  000...00000000...000000 0111
      ----------------------------
      000...00000000...000000 0101 = 5
      
a|b = 000...00000000...000000 0101
	  000...00000000...000000 0111
      ----------------------------
      000...00000000...000000 0111 = 7 

a^b = 000...00000000...000000 0101
	  000...00000000...000000 0111
      ----------------------------
      000...00000000...000000 0010 = 2

~b =  000...00000000...000000 0111
	  ----------------------------
	  111...11111111...111111 1000  = 7의 보수 -8
	  
```



<< 왼쪽 시프트*2 비트를 왼쪽으로 이동 >> 오른쪽으로 이동 /2 : 이진법으로 바꾼 후 이동

```
d=5
d>>1 //000,,,0,0000000000101  -> 000,,,0,0000000000010

결과값 : 2
```



#### 대입 연산자 : 연산 후 결과를 대입하는 연산식을 간략하게 입려할 수 있도록 대입 연산자를 제공. 대입 연산자는 산술, 관계, 비트, 논리 연산자에 모두 적용 가능

+=, -=, *=, /=, %=, <<=, >>=  



#### 조건연산자

조건 ? 수식 1 : 수식2;

```
a=1, b=2, c=3, d=4

b*=a>b?a:b  // a>b? x b가 선택 b*=b -> 2x2=4

c-=a<b?a-b:b-a; a<b? o a-b가 선택 c-=a-b  c-=-1 3-(-1) =4

c+=b<b? ++a:b++; b<b? x b++가 선택 b++ = 2 3+=2 =5

```





#### 기타 연산자

sizeof 자료형 크기를 표시한다 / 출력 형태

, 한줄에 두개이상의 수식을 작성하거나 변수 정의.  순서는 왼쪽에서 오른쪽

(자료형) 자료형을 다른 자료형으로 변환하는 연산자



#### 우선순위

단항 연산자(!, ~, ++, --, sizeof) 

이항연산자(산술(*/% +-) 시프트(<< >>), 관계(<=, <, >, >=, ==, !=) 비트(&, ^, |) 논리(&&, ||)) 

삼항연산자 (? :)

대입연산자 = += -= *= /= %= <<= >>=

순서연산자(,)

```
a=2, b=3, c=4, d=5

1. d*=10-b++; b++ = 3 ->  d*=(10-3) -> d=5*7 = 35
2. d+=b*=c/=a; d+(b*(c/a)) -> 5+(3*(4/2)) = 11
3. a-=++d/b--; 6/3 = 2 a-2 = 0
4. b+=c*=a<<2; a<<2 = 8   3+(4*8) = 35
5. a%=c|b&d-b; d-b=2 a%(4|3&2) 

000...00000000...000000 0011
000...00000000...000000 0010
----------------------------
000...00000000...000000 0010 = 2 
000...00000000...000000 0100 
----------------------------
000...00000000...000000 00110 = 6
2%6 = 2

6. c*=d<<=(b==++a);

4*=5<<=(3==3) -> 4*=5<<=1 4*10 = 40


```





# 조건문

if

```
if(true){
then 절
}
```

```
if(){
}else{
}
```

```
if(){
}else if(){
}else{
}
```

스위치

```
switch(입력값){
case 1 :
case 2 :
case 3 :
...
default: //입력값이 주어진 케이스에 없으면 실행
}
```

각 케이스마다 break가 없으면 처음 실행된 case 부터 아래로 쭉쭉 다 실행

break 가 있으면 해당 케이스만 하고 즉시 중지



# 반복문

```
while(i<10){
i++
}
```

조건에 true를 넣어버리면 무한반복 

```
for(초기화; 종료조건; 반복실행){
}
```

초기값을 0으로 , 원하는 반복횟수m를 i<m 로 



for(int i=1; i<=5; i++){

 m+= i*2

}



for (int i=0, i<=10, i+=2){

m+=i

}

# 배열

```
string[] classgroup = { "a","b","c"};
string[] members = new string[3]; // 3명이고 인덱스는 0,1,2
```

string[]는 문자열의 배열이라는 의미. 배열을 선언할 때는 데이터 타입 뒤에 []를 붙혀야함



```
for (string e : members) {
e에 관한 실행문
}
```

배열 members의 값을 변수 e에 담아서 중괄호 구간 안으로 전달해 줌



한계 : 초기화 할 때 크기가 정해짐  -> 컬렉션 기능을 이용하면 유연하게 사용 가능



# 메소드 정의와 호출

```
public static void main(string[] args){

  numbering(); // 호출된 메소드

}

public static void numbering(){ //메소드 정의
}
```

정의와 호출의 차이점  : ()로 끝나면 호출된 메소드 {}로 되면 정의



main

main 메소드는 규칙 , 만들고 싶은 프로그램이 있다면 반드시 main 안에 넣어야함

메소드를 씀으로서 재활용이 가능 -> 중복되는 부분을 없앨 수 있고 수정이 용이하다



- 외부 자극 : 입력, 반응 : 출력 /메소드는 프로그램 안에서 동작하는 하나의 작은 프로그램. 입력값에 따라  출력값도 달라지게 할수도

-> 매개변수 parameter 를 통해 이루어진다. 메소드를 정의할 때 ()안에 변수를 넣고 호출할때 인자값을 넣어서 호출. 복수값도 가능

- 결과값을 화면에 출력하지 않고 그냥 반환 받고 싶을 때는 return을 사용한다. return 은 값을 반환시키기도 하지만 메소드를 중단시키기도 한다. 또한 이때는 반환할 값의 데이터 형식을 메소드의 이름 옆에 명시해주어야한다. 반환값이 없으면 void

```
 public static void main(String[] args) {
        String result = numbering(1, 5);
        System.out.println(result);
```

여러개의 데이터를 반환받고 싶을 땐? 배열을 이용한다.

```
public class ReturnDemo4 {
 
    public static String[] getMembers() {
        String[] members = { "최진혁", "최유빈", "한이람" };
        return members;
    }
 
    public static void main(String[] args) {
        String[] members = getMembers();
        }
```

------------------------------------------------------------







# 입력과 출력

string[] args : 매개변수( 메소드가 호출될 때 전달된 입력 값을 메소드 내부로 전달. ) 입력값의 파라미터로 동작

```
package org.opentutorial.javatutorials.io;

class lnputdemo{
	public ststic void main(String[] args){
		sytem.out.println(args.length); // 입력받은 배열의 길이를 출력한다.
	}
}
```

for-each 구문

```
class InputForeachDemo{
    public static void main(String[] args){
        for(String e : args){
            System.out.println(e);
        }
    } // 사용자로부터 arge라는 문자열배열에 값을 입력받아서 그 값들을 for문을 이용해 하나씩 출력
}
```



#### 앱이 실행중에 입력 받기

scanner : 자바에서 기본적으로 제공하는 라이브러리. 사용자의 입력을 쉽게 잡을 수 있다.

```
package org.opentutorial.javatutorials.io;

import java.util.Scanner; //scanner 로드
 
public class ScannerDemo {
 
    public static void main(String[] args) {  //입력값을 입력하지 않았기때문에 아무런 값이 입력되지 않는다.
        Scanner sc = new Scanner(System.in); // system.in = 사용자가 입력한 값, 스캐너라는 객체를 새로 만들어서 사용자가 입력한 값을 알아냄 ()안에 파일명이 들어가면 파일의 내용을 스캐닝/ 알아낸 것을 sc라는 변수에 담아냄. 스캐너 객체를 sc로 제어할 수 있다. 
        
        int i = sc.nextInt(); //실행을 멈추고 입력을 다 하는걸 기다리고 있는 상태에서 int 값을 입력받으면 아이라는 변수에 담김
        System.out.println(i*1000); 
        sc.close();
    }
```

-> 한번만 입력하고 결과값이 나오면 종료



변수형 변수 = new 변수형()

메소드 변수 = new 메소드()





#### 계속하여 상호작용하는 프로그램

```
package org.opentutorials.javatutorials.io;
 
import java.util.Scanner;
 
public class Scanner2Demo {
 
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        while(sc.hasNextInt()) { //입력한 값이 정수면 true 반복문 실행, 숫자가 아니라면 반복문 종료
            System.out.println(sc.nextInt()*1000); // 사용자가 입력한 정수값에 1000을 곱하고 출력 
        }
        sc.close();
    }
 
}
```

- system.in : 실행되면 자바는 사용자의 입력이 있을 때 까지 변수 i에 값을 할당하지 않고 대기상태에 있게 된다. 

출력

```
System.out.print(); // 다음에 출력하는 것이 바로 뒤에 붙어서 출력
System.out.println(); // 다음에 출력하는 것이 한줄 띄어서 출력 출력이 된후 한줄이 띄어짐
```



#### 파일의 내용을 입력값으로 유입시키는 프로그램

```
package org.opentutorials.javatutorials.io;
 
import java.util.Scanner; 
import java.io.*;
 
public class Scanner3Demo {
 
    public static void main(String[] args) {
        try {
            File file = new File("out.txt"); // 파일 객체를 생성 해서 파일 out.txt를 넣음
            Scanner sc = new Scanner(file); //변수안에 있는 파일을 스캐너가 입력값으로 받아와서 스캐너 변수에 저장 
            while(sc.hasNextInt()) {
                System.out.println(sc.nextInt()*1000); 
            }
            sc.close();
        } catch(FileNotFoundException e){ //파일을 찾을 수 없는 경우 화면에 출력하고 예외처리
            e.printStackTrace();
        }
         
    }
 
}
```



# 객체지향 프로그래밍 OOP

로직을 상태와 행위로 이루어진 객체로 만드는 것. 기계의 부품처럼 조립해서 하나의 프로그램으로 만드는 것

프로시저보다는 명령과 데이터로 구성된 객체를 중심으로 하는 프로그래밍. 한 프로그램을 다른 프로그램에서 이용 가능



- 장단점

  상속을 통한 재사용과 시스템 확장이 용이

  코드의 재활용성이 높다. 이식성이 높다

  자연적인 모델링에 의해 분석과 설계를 쉽고 효율적으로 할 수 있다. 

  사용자와 개발자 사이의 이해를 쉽게 해줌

  대형 프로그램의 작성이 용이

  소프트웨어 개발 및 유지보수가 용이

  

  구현을 지원해주는 정형화된 분석 및 설계 방법이 없다

  구현 시 처리 시간이 지연







#### 클레스와 인스턴스 그리고 객체

##### 접근 지정자 class 클래스명 {

필드

메소드

##### }

설계도 객체를 정의해 놓은 것. 객체를 만들기 위한것

연관되어 있는 변수와 메소드의 집합

##### 객체

실제로 존재하는 것 ( 사물, 개념)

클래스 모양 그대로 생성된 실체

```
Calculator c1 = new Calculator();
// 클래스 calculator를 구체적인 제품으로 만드는 명령. 이렇게 만들어진 제품이 인스턴스
new를 통해 만든 인스턴스를 변수 c1에 담았다. 이제 c1을 갖고 인스턴스를 제어할 수 있다. 
```



##### 인스턴스

객체를 클래스의 인스턴스라고 한다. 



클래스 안에 메소드가 포함되어있다. 그 메소드는 클래스의 구성으로 만들어진 객체를 이용할 수 있다.

메소드는 각각의 역할이 있음

그 클래스의 구성을 갖고 다른 클래스 안의 메인 메소드에서 객체를 생성해줄 수 있다.

```
package myjava;
class Calculator{
    static double PI = 3.14; //static을 맴버 앞에 붙이면 클래스의 맴버가 된다.
    int left, right; //클래스의 구성 파이, 레프트, 라이트
    static int base = 0; //클래스 변수를 만들기 위해선 앞에 스테틱을 써준다!!!
    //메소드를 세개 만들어 줬다. 변수를 넣는 메소드. 덧셈하는 메소드 . 평균 구하는 메소드
    public void setOprands ( int left, int right) {
        this.left = left; //객체.setOprands(변수, 변수)를 하게 되면 객체안에 값이 저장된다. 값을 메인 메소드에서 넣을 수 있는 방법! 이렇게 안하면 일일이 넣어줘야겠지..
        this.right = right; //
    }
    
    public void sum() { //합해서 출력까지 해주는 것..!
        System.out.println(this.left + this.right+base);
        
    }
    public void avg() { //평균을 구해서 출력까지 해주는 것!
        System.out.println(this.left + this.right/2+base);
    }
}    
    
    
public class Caculatordemo {
//나눌 이유가 딱히 없는 것 같은데 나눈 이유를 생각해보자면 위에 클래스는 숫자 객체를 만들 구성들과  그 구성을 이용해 만들
   // 메소드를 모아놨다. 그러면 메인 메소드 에서는 그 메소드를 사용하기만 하면 된다!
        public static void main(String[] args) {
     
            Calculator c1 = new Calculator();
            c1.setOprands(3,6);
            Calculator.base=10; // 클래스 변수는 클래스.변수 로 써준다!!!!!
            System.out.println(c1.PI); // c1객체 생성 했고 c1의 파이값 출력했고.. 
            c1.sum(); //항상 메소드를 사용할땐 사용할 객체.메소드!!!!
            c1.avg();
            
            
     
            Calculator c2 = new Calculator();
            System.out.println(c2.PI);
            c1.sum(); //항상 메소드를 사용할땐 사용할 객체.메소드!!!!
            c1.avg();
            System.out.pr02intln(Calculator.PI);
     
        }
}
```



020723

# 메소드 : 객체의 행동 또는 기능



#### 입력값이 있고 리턴값도 있는 메소드가 평범한 상태

```
public int sum(int a, intb){   
	return a+b;
}
```

위와 같은 메소드는 리턴값받을변수 = 객체.메소드명(입력인수1, 입력인수2, ...) 로 사용됨

```
Test myTest = new Test();
int c = myTest.sum(a,b);
```



#### 입력값이 없을 경우 - 메소드명()

```
public String say() {
	return "hi"
} // 입력값 없음 리턴 값 string
```

```
Test mytest = new Test();
String a = mytest.say();
System.out.println(a);
```

 hi



#### 리턴 값이 없는 경우 void

```
public void sum (int a , int b){
	System.out.println(a+"과 "+b+"의 합은 "+(a+b)+"입니다.");
}
```

```
Test myTest = new Test();
myTest.sum(3,4);
```

3과 4의 합은 7입니다.



#### return의 또 다른 쓰임새

특별한 경우 메소드를 빠져나가기를 원할 때 사용할 수 있다.

```
public void say_nick(String nick){
	if ("fool".equals(nick)){ //입력값이 fool하고 일치한다면 바로 종료 호출했던 곳으로 돌아감
		return;// 많이 쓰면 가독성이 떨어짐 모아서 한군데에 쓰자
	}
	System.out.println("나의 별명은 " +nick+"입니다.");
}
```

단 리턴 값이 void 일때만 가능하다. 리턴자료형이 명시되어 있는 메소드에서 return 문만 작성하면 컴파일시 오류가 난다. -> return null 을 쓰면됨

#### 메소드 내에서 선언된 변수의 유효 범위 스코프

```
class Test {
    public void vartest(int a) {
        a++;
    }

    public static void main(String[] args) { 
        int a = 1; // a라는 int자료형의 변수를 생성하고 1을 대입
        Test myTest = new Test();
        myTest.vartest(a);//메소드에 a를 주어 호출 
        System.out.println(a); //a값을 출력 이때 a는 메소드 내에서 사용되어지는 변수 1 이 들어있기 때문에 1이 출력
    }
}
```

메소드에서만 쓰이는 변수는 메소드 밖의 변수들과 전혀 상관이 없다. 

이런 메소드 내에서 쓰는 변수를 로컬변수라 한다.

원시/참조 자료형 class로 생성되는 것들

  



그럼 원하는 값을 얻기 위해선?

```
public int vartest(int a) {
    a++;
*** return a; // a값을 리턴한다.
}

public static void main(String[] args) {
    int a = 1;
    Test myTest = new Test();
*** a = myTest.vartest(a); 메소드의 리턴값으로 나와 a값이 변경된다.
    System.out.println(a);
}
```



#### 객체를 넘기는 방법

```
public class Test{

	int a;//속성
	
	public void vartest(Test test){
		test.a++; //객체를 입력받아 해당 객체의 객체변수 a의 값을 1만큼 증가시킴
	}
}

public static void main(String[] args){
	Test myTest = new Test();
	myTest.a = 1;
	myTest.vartest(myTest); // Test 클래스의 객체인 myTest를 넘기도록 다음과 같이 수정했다.
	System.out.println(myTest.a);
}

```

파라미터가 객체. 객체를 전달 받으면 메소드 내의 객체는 전달 받은 객체 그 자체로 수행된다. 

따라서 입력으로 전달받은 myTest 객체의 객체변수 a의 값이 증가하게 되는 것이다.

값인지 객체인지 구별하는 기준 : 입력항목의 자료형이 primitive 자료형인지 아닌지에 따라 나뉜다. int자료형과 같은 primitive 자료형은 값이 전달되고 그 이외는 객체가 전달.



#### 객체를 전달하는 대신 this 이용하기

```
package myjava;
public class Test {

    int a; 

    public void vartest() {
        this.a++; // this 를 이용해 해당 객체에 접근할 수 있기 때문에 class자기자신
    }

    public static void main(String[] args) {
        Test myTest = new Test();
        myTest.a = 1;
        myTest.vartest();
        System.out.println(myTest.a);
    }
}
```



#### Call my value

