## 200721

# 변수



자바는 다른 언어에 비해 자료형 선언 같은 것들이 엄격하다. 컴파일 단계에서 예상되는 문제점을 예측할 수 있다.  금융이나 과학적 계산처럼 엄격함이 요구되는 분야에 주로 사용

\를 " 앞에 위치시키면 단순히 문자로 해석하도록 할 수 있다.

실수형 변수 : double  8byte / float 4byte  부동소수점 근삿값으로 소수를 표현    mbyte  : 2^(m*8) 개의 숫자 가능 0중심

 ```
float a = 2.0F 
float a = (float)100.0
//정수가 아닌 실수값은 그 자체로 double 값이다. 그러므로 float에 저장하기 위해선 형변환을 해야한다.
long a = 2147483648L //int에 저장될 수 있는 최댓값을 넘었기 때문에
 ```

```
byte a = 100;
short b = 200; //이건 가능 int 허용하기 때문   
```



byte -> short char -> int -> long -> float -> double

자동형 변환은 작은 범위에서 넓은 데이터 타입으로의 변환만 허용이고 형변환을 따로 안해줘도 저절로 상수 값이 변환되어 변수에 저장되는 것이다.

명시적 형변환은 (데이터타입)데이터 값 형태로 직접 써서 변환 시켜주는 것이다. 이는 넓은 데이터에서 좁은 데이터로 바꾸는 데 쓰임 이는 데이터 손실이 일어나므로 버그를 없애기위해 사용



문자형 변수 : char 2byte

문자열 : string 글자들의 집합  2*글자수 byte

모든 객체는 힙 메모리에 위치한다. 힙메모리는 프로세스가 실행될 때 운영체계로 부터 할당, 자바는 자바 가상머신이 실행될 때 운영체계로 부터 힙메모리를 할당받는다. 힙메모리는 고정되어 있을 수도 가변적일 수도 있다. 초기힙, 최대 힙 메모리의 양을 설정할 수도 있다. 최대는 2GB! 따라서 string 클래스의 문자열의 최대 가능 길읻 2GB가 한계

```
java-Xms16s Xms128m Myclass
(초기값 16, 최대 힙 메모리 128)
```



-> string 클래스의 문자열 길이의 한계는 하드웨어 머신과 운영체계에서 허용하는 최대한의 크기까지 가능. 특별히 규약에서 제약하는 사항은 없다. 자바 가상 머신에 따라 힙 메모리 할당에 옵션 설정이 있을 수 있다.

 변수 두개 동시 선언 가능

alert?



레퍼런스 변수 : 객체를 가리킨다. 엄밀히 말하면 객체의 주소 정보를 담고 있다. 대문자로 시작

간접적으로 저장 , 객체의 주소를 저장함으로서 ...

레퍼런스 변수는 특정 클래스 타입의 변수다.

레퍼런스 변수는 객체를 가리킬 수 있다.

레퍼런스 변수를 사용하여 해당 객체의 필드와 메소드에 접근할 수 있다.

클래스에서 생성된 객체가 하나의 변수로 사용 되는 것.

객체를 생성할때... 클래스 타입으로.. 만드는게..레퍼런스..변수......!!!!!!!!!!!!!!!!!!!!!



원시형 변수 : 소문자로 시작 . 값을 직접 저장

int, double, boolean, char





# 연산자



정수 * 정수 - 정수

정수*실수 - 실수 로 형변환



boolean 참 거짓을 의미하는 데이터 타입

.equals 는 문자열을 비교할 때 사용하는 메소드 a.equals(b)



#### 산술 연산자

+, -, *, /, %, 

##### 증감 연산자 

++, --



#### 관계연산자 : 두수를 비교하여 참(1)거짓(0) 을 결과로 얻음

== 같다, != 같지않다, >, >=, <, <= 



#### 비트 연산자 : 이진법 0,1로 연산하여 결과를 얻는 연산자

& and  모든 비트가 1일때만 1 이더넷 주소 서브넷마스크 

^ xor  모든 비트가 같으면 0 하나라도 다르면 1

| or  모든비트 중 한비트라도 1이면 1

~ not 각 비트의 부정 0이면 1 1이면 0

```
a=5
b=7

a&b = 000...00000000...000000 0101
	  000...00000000...000000 0111
      ----------------------------
      000...00000000...000000 0101 = 5
      
a|b = 000...00000000...000000 0101
	  000...00000000...000000 0111
      ----------------------------
      000...00000000...000000 0111 = 7 

a^b = 000...00000000...000000 0101
	  000...00000000...000000 0111
      ----------------------------
      000...00000000...000000 0010 = 2

~b =  000...00000000...000000 0111
	  ----------------------------
	  111...11111111...111111 1000  = 7의 보수 -8
	  
```



<< 왼쪽 시프트*2 비트를 왼쪽으로 이동 >> 오른쪽으로 이동 /2 : 이진법으로 바꾼 후 이동

```
d=5
d>>1 //000,,,0,0000000000101  -> 000,,,0,0000000000010

결과값 : 2
```



#### 대입 연산자 : 연산 후 결과를 대입하는 연산식을 간략하게 입려할 수 있도록 대입 연산자를 제공. 대입 연산자는 산술, 관계, 비트, 논리 연산자에 모두 적용 가능

+=, -=, *=, /=, %=, <<=, >>=  



#### 조건연산자

조건 ? 수식 1 : 수식2;

```
a=1, b=2, c=3, d=4

b*=a>b?a:b  // a>b? x b가 선택 b*=b -> 2x2=4

c-=a<b?a-b:b-a; a<b? o a-b가 선택 c-=a-b  c-=-1 3-(-1) =4

c+=b<b? ++a:b++; b<b? x b++가 선택 b++ = 2 3+=2 =5

```





#### 기타 연산자

sizeof 자료형 크기를 표시한다 / 출력 형태

, 한줄에 두개이상의 수식을 작성하거나 변수 정의.  순서는 왼쪽에서 오른쪽

(자료형) 자료형을 다른 자료형으로 변환하는 연산자



#### 우선순위

단항 연산자(!, ~, ++, --, sizeof) 

이항연산자(산술(*/% +-) 시프트(<< >>), 관계(<=, <, >, >=, ==, !=) 비트(&, ^, |) 논리(&&, ||)) 

삼항연산자 (? :)

대입연산자 = += -= *= /= %= <<= >>=

순서연산자(,)

```
a=2, b=3, c=4, d=5

1. d*=10-b++; b++ = 3 ->  d*=(10-3) -> d=5*7 = 35
2. d+=b*=c/=a; d+(b*(c/a)) -> 5+(3*(4/2)) = 11
3. a-=++d/b--; 6/3 = 2 a-2 = 0
4. b+=c*=a<<2; a<<2 = 8   3+(4*8) = 35
5. a%=c|b&d-b; d-b=2 a%(4|3&2) 

000...00000000...000000 0011
000...00000000...000000 0010
----------------------------
000...00000000...000000 0010 = 2 
000...00000000...000000 0100 
----------------------------
000...00000000...000000 00110 = 6
2%6 = 2

6. c*=d<<=(b==++a);

4*=5<<=(3==3) -> 4*=5<<=1 4*10 = 40


```





# 조건문

if

```
if(true){
then 절
}
```

```
if(){
}else{
}
```

```
if(){
}else if(){
}else{
}
```

스위치

```
switch(입력값){
case 1 :
case 2 :
case 3 :
...
default: //입력값이 주어진 케이스에 없으면 실행
}
```

각 케이스마다 break가 없으면 처음 실행된 case 부터 아래로 쭉쭉 다 실행

break 가 있으면 해당 케이스만 하고 즉시 중지



# 반복문

```
while(i<10){
i++
}
```

조건에 true를 넣어버리면 무한반복 

```
for(초기화; 종료조건; 반복실행){
}
```

초기값을 0으로 , 원하는 반복횟수m를 i<m 로 



for(int i=1; i<=5; i++){

 m+= i*2

}



for (int i=0, i<=10, i+=2){

m+=i

}

# 배열

```
string[] classgroup = { "a","b","c"};
string[] members = new string[3]; // 3명이고 인덱스는 0,1,2
```

string[]는 문자열의 배열이라는 의미. 배열을 선언할 때는 데이터 타입 뒤에 []를 붙혀야함



```
for (string e : members) {
e에 관한 실행문
}
```

배열 members의 값을 변수 e에 담아서 중괄호 구간 안으로 전달해 줌



한계 : 초기화 할 때 크기가 정해짐  -> 컬렉션 기능을 이용하면 유연하게 사용 가능



# 메소드 정의와 호출

```
public static void main(string[] args){

  numbering(); // 호출된 메소드

}

public static void numbering(){ //메소드 정의
}
```

정의와 호출의 차이점  : ()로 끝나면 호출된 메소드 {}로 되면 정의



main

main 메소드는 규칙 , 만들고 싶은 프로그램이 있다면 반드시 main 안에 넣어야함

메소드를 씀으로서 재활용이 가능 -> 중복되는 부분을 없앨 수 있고 수정이 용이하다



- 외부 자극 : 입력, 반응 : 출력 /메소드는 프로그램 안에서 동작하는 하나의 작은 프로그램. 입력값에 따라  출력값도 달라지게 할수도

-> 매개변수 parameter 를 통해 이루어진다. 메소드를 정의할 때 ()안에 변수를 넣고 호출할때 인자값을 넣어서 호출. 복수값도 가능

- 결과값을 화면에 출력하지 않고 그냥 반환 받고 싶을 때는 return을 사용한다. return 은 값을 반환시키기도 하지만 메소드를 중단시키기도 한다. 또한 이때는 반환할 값의 데이터 형식을 메소드의 이름 옆에 명시해주어야한다. 반환값이 없으면 void

```
 public static void main(String[] args) {
        String result = numbering(1, 5);
        System.out.println(result);
```

여러개의 데이터를 반환받고 싶을 땐? 배열을 이용한다.

```
public class ReturnDemo4 {
 
    public static String[] getMembers() {
        String[] members = { "최진혁", "최유빈", "한이람" };
        return members;
    }
 
    public static void main(String[] args) {
        String[] members = getMembers();
        }
```

------------------------------------------------------------







# 입력과 출력

string[] args : 매개변수( 메소드가 호출될 때 전달된 입력 값을 메소드 내부로 전달. ) 입력값의 파라미터로 동작

```
package org.opentutorial.javatutorials.io;

class lnputdemo{
	public ststic void main(String[] args){
		sytem.out.println(args.length); // 입력받은 배열의 길이를 출력한다.
	}
}
```

for-each 구문

```
class InputForeachDemo{
    public static void main(String[] args){
        for(String e : args){
            System.out.println(e);
        }
    } // 사용자로부터 arge라는 문자열배열에 값을 입력받아서 그 값들을 for문을 이용해 하나씩 출력
}
```



#### 앱이 실행중에 입력 받기

scanner : 자바에서 기본적으로 제공하는 라이브러리. 사용자의 입력을 쉽게 잡을 수 있다.

```
package org.opentutorial.javatutorials.io;

import java.util.Scanner; //scanner 로드
 
public class ScannerDemo {
 
    public static void main(String[] args) {  //입력값을 입력하지 않았기때문에 아무런 값이 입력되지 않는다.
        Scanner sc = new Scanner(System.in); // system.in = 사용자가 입력한 값, 스캐너라는 객체를 새로 만들어서 사용자가 입력한 값을 알아냄 ()안에 파일명이 들어가면 파일의 내용을 스캐닝/ 알아낸 것을 sc라는 변수에 담아냄. 스캐너 객체를 sc로 제어할 수 있다. 
        
        int i = sc.nextInt(); //실행을 멈추고 입력을 다 하는걸 기다리고 있는 상태에서 int 값을 입력받으면 아이라는 변수에 담김
        System.out.println(i*1000); 
        sc.close();
    }
```

-> 한번만 입력하고 결과값이 나오면 종료



변수형 변수 = new 변수형()

메소드 변수 = new 메소드()





#### 계속하여 상호작용하는 프로그램

```
package org.opentutorials.javatutorials.io;
 
import java.util.Scanner;
 
public class Scanner2Demo {
 
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        while(sc.hasNextInt()) { //입력한 값이 정수면 true 반복문 실행, 숫자가 아니라면 반복문 종료
            System.out.println(sc.nextInt()*1000); // 사용자가 입력한 정수값에 1000을 곱하고 출력 
        }
        sc.close();
    }
 
}
```

- system.in : 실행되면 자바는 사용자의 입력이 있을 때 까지 변수 i에 값을 할당하지 않고 대기상태에 있게 된다. 

출력

```
System.out.print(); // 다음에 출력하는 것이 바로 뒤에 붙어서 출력
System.out.println(); // 다음에 출력하는 것이 한줄 띄어서 출력 출력이 된후 한줄이 띄어짐
```



#### 파일의 내용을 입력값으로 유입시키는 프로그램

```
package org.opentutorials.javatutorials.io;
 
import java.util.Scanner; 
import java.io.*;
 
public class Scanner3Demo {
 
    public static void main(String[] args) {
        try {
            File file = new File("out.txt"); // 파일 객체를 생성 해서 파일 out.txt를 넣음
            Scanner sc = new Scanner(file); //변수안에 있는 파일을 스캐너가 입력값으로 받아와서 스캐너 변수에 저장 
            while(sc.hasNextInt()) {
                System.out.println(sc.nextInt()*1000); 
            }
            sc.close();
        } catch(FileNotFoundException e){ //파일을 찾을 수 없는 경우 화면에 출력하고 예외처리
            e.printStackTrace();
        }
         
    }
 
}
```



# 객체지향 프로그래밍 OOP

로직을 상태와 행위로 이루어진 객체로 만드는 것. 기계의 부품처럼 조립해서 하나의 프로그램으로 만드는 것

프로시저보다는 명령과 데이터로 구성된 객체를 중심으로 하는 프로그래밍. 한 프로그램을 다른 프로그램에서 이용 가능



- 장단점

  상속을 통한 재사용과 시스템 확장이 용이

  코드의 재활용성이 높다. 이식성이 높다

  자연적인 모델링에 의해 분석과 설계를 쉽고 효율적으로 할 수 있다. 

  사용자와 개발자 사이의 이해를 쉽게 해줌

  대형 프로그램의 작성이 용이

  소프트웨어 개발 및 유지보수가 용이

  

  구현을 지원해주는 정형화된 분석 및 설계 방법이 없다

  구현 시 처리 시간이 지연







#### 클레스와 인스턴스 그리고 객체

##### 접근 지정자 class 클래스명 {

필드

메소드

##### }

설계도 객체를 정의해 놓은 것. 객체를 만들기 위한것

연관되어 있는 변수와 메소드의 집합

##### 객체

실제로 존재하는 것 ( 사물, 개념)

클래스 모양 그대로 생성된 실체

```
Calculator c1 = new Calculator();
// 클래스 calculator를 구체적인 제품으로 만드는 명령. 이렇게 만들어진 제품이 인스턴스
new를 통해 만든 인스턴스를 변수 c1에 담았다. 이제 c1을 갖고 인스턴스를 제어할 수 있다. 
```



##### 인스턴스

객체를 클래스의 인스턴스라고 한다. 



클래스 안에 메소드가 포함되어있다. 그 메소드는 클래스의 구성으로 만들어진 객체를 이용할 수 있다.

메소드는 각각의 역할이 있음

그 클래스의 구성을 갖고 다른 클래스 안의 메인 메소드에서 객체를 생성해줄 수 있다.

```
package myjava;
class Calculator{
    static double PI = 3.14; //static을 맴버 앞에 붙이면 클래스의 맴버가 된다.
    int left, right; //클래스의 구성 파이, 레프트, 라이트
    static int base = 0; //클래스 변수를 만들기 위해선 앞에 스테틱을 써준다!!!
    //메소드를 세개 만들어 줬다. 변수를 넣는 메소드. 덧셈하는 메소드 . 평균 구하는 메소드
    public void setOprands ( int left, int right) {
        this.left = left; //객체.setOprands(변수, 변수)를 하게 되면 객체안에 값이 저장된다. 값을 메인 메소드에서 넣을 수 있는 방법! 이렇게 안하면 일일이 넣어줘야겠지..
        this.right = right; //
    }
    
    public void sum() { //합해서 출력까지 해주는 것..!
        System.out.println(this.left + this.right+base);
        
    }
    public void avg() { //평균을 구해서 출력까지 해주는 것!
        System.out.println(this.left + this.right/2+base);
    }
}    
    
    
public class Caculatordemo {
//나눌 이유가 딱히 없는 것 같은데 나눈 이유를 생각해보자면 위에 클래스는 숫자 객체를 만들 구성들과  그 구성을 이용해 만들
   // 메소드를 모아놨다. 그러면 메인 메소드 에서는 그 메소드를 사용하기만 하면 된다!
        public static void main(String[] args) {
     
            Calculator c1 = new Calculator();
            c1.setOprands(3,6);
            Calculator.base=10; // 클래스 변수는 클래스.변수 로 써준다!!!!!
            System.out.println(c1.PI); // c1객체 생성 했고 c1의 파이값 출력했고.. 
            c1.sum(); //항상 메소드를 사용할땐 사용할 객체.메소드!!!!
            c1.avg();
            
            
     
            Calculator c2 = new Calculator();
            System.out.println(c2.PI);
            c1.sum(); //항상 메소드를 사용할땐 사용할 객체.메소드!!!!
            c1.avg();
            System.out.pr02intln(Calculator.PI);
     
        }
}
```



020723

# 메소드 : 객체의 행동 또는 기능



#### 입력값이 있고 리턴값도 있는 메소드가 평범한 상태

```
public int sum(int a, intb){   
	return a+b;
}
```

위와 같은 메소드는 리턴값받을변수 = 객체.메소드명(입력인수1, 입력인수2, ...) 로 사용됨

```
Test myTest = new Test();
int c = myTest.sum(a,b);
```



#### 입력값이 없을 경우 - 메소드명()

```
public String say() {
	return "hi"
} // 입력값 없음 리턴 값 string
```

```
Test mytest = new Test();
String a = mytest.say();
System.out.println(a);
```

 hi



#### 리턴 값이 없는 경우 void

```
public void sum (int a , int b){
	System.out.println(a+"과 "+b+"의 합은 "+(a+b)+"입니다.");
}
```

```
Test myTest = new Test();
myTest.sum(3,4);
```

3과 4의 합은 7입니다.



#### return의 또 다른 쓰임새

특별한 경우 메소드를 빠져나가기를 원할 때 사용할 수 있다.

```
public void say_nick(String nick){
	if ("fool".equals(nick)){ //입력값이 fool하고 일치한다면 바로 종료 호출했던 곳으로 돌아감
		return;// 많이 쓰면 가독성이 떨어짐 모아서 한군데에 쓰자
	}
	System.out.println("나의 별명은 " +nick+"입니다.");
}
```

단 리턴 값이 void 일때만 가능하다. 리턴자료형이 명시되어 있는 메소드에서 return 문만 작성하면 컴파일시 오류가 난다. -> return null 을 쓰면됨

#### 메소드 내에서 선언된 변수의 유효 범위 스코프

```
class Test {
    public void vartest(int a) {
        a++;
    }

    public static void main(String[] args) { 
        int a = 1; // a라는 int자료형의 변수를 생성하고 1을 대입
        Test myTest = new Test();
        myTest.vartest(a);//메소드에 a를 주어 호출 
        System.out.println(a); //a값을 출력 이때 a는 메소드 내에서 사용되어지는 변수 1 이 들어있기 때문에 1이 출력
    }
}
```

메소드에서만 쓰이는 변수는 메소드 밖의 변수들과 전혀 상관이 없다. 

이런 메소드 내에서 쓰는 변수를 로컬변수라 한다.

원시/참조 자료형 class로 생성되는 것들

  



그럼 원하는 값을 얻기 위해선?

```
public int vartest(int a) {
    a++;
*** return a; // a값을 리턴한다.
}

public static void main(String[] args) {
    int a = 1;
    Test myTest = new Test();
*** a = myTest.vartest(a); 메소드의 리턴값으로 나와 a값이 변경된다.
    System.out.println(a);
}
```



#### 객체를 넘기는 방법

```
public class Test{

	int a;//속성
	
	public void vartest(Test test){
		test.a++; //객체를 입력받아 해당 객체의 객체변수 a의 값을 1만큼 증가시킴
	}
}

public static void main(String[] args){
	Test myTest = new Test();
	myTest.a = 1;
	myTest.vartest(myTest); // Test 클래스의 객체인 myTest를 넘기도록 다음과 같이 수정했다.
	System.out.println(myTest.a);
}

```

파라미터가 객체. 객체를 전달 받으면 메소드 내의 객체는 전달 받은 객체 그 자체로 수행된다. 

따라서 입력으로 전달받은 myTest 객체의 객체변수 a의 값이 증가하게 되는 것이다.

값인지 객체인지 구별하는 기준 : 입력항목의 자료형이 primitive 자료형인지 아닌지에 따라 나뉜다. int자료형과 같은 primitive 자료형은 값이 전달되고 그 이외는 객체가 전달.



#### 객체를 전달하는 대신 this 이용하기

```
package myjava;
public class Test {

    int a; 

    public void vartest() {
        this.a++; // this 를 이용해 해당 객체에 접근할 수 있기 때문에 class자기자신
    }

    public static void main(String[] args) {
        Test myTest = new Test();
        myTest.a = 1;
        myTest.vartest();
        System.out.println(myTest.a);
    }
}
```



#### Call by value

```
package myjava;
class Updater {
    public void update(int count) {
        count++;
    }
}

public class Counter {
    int count = 0;  // 객체변수
    public static void main(String[] args) {        
        Counter myCounter = new Counter();
        myCounter.count=1;
        System.out.println("before update:"+myCounter.count);
        Updater myUpdater = new Updater();
        myUpdater.update(myCounter.count); // 객체변수값을 넘겨줌
        System.out.println("after update:"+myCounter.count);
    }
}
```

1, 1 더해진 값이 출력되지 않는다.

update 메소드는 원시 자료형 값을 전달받았기 때문이다.



-> 객체를 변수로 받기

```
package myjava;
class Updater {
public void update(Counter counter) {
    counter.count++;    
  }
}
class Counter{
    int count=0;
    public static void main(String[] args) {
        Counter mycoun = new Counter();
        mycoun.count=1;
        System.out.println("before update:"+mycoun.count);
// 객체를 변수를 넣어 다른 클래스의 객체의 메소드를 호출
        Updater myup=new Updater();
        myup.update(mycoun);
        System.out.println("after update:"+mycoun.count);
        
    }
}
```



이렇게 메소드의 입력으로 객체를 전달받으면 메소드가 입력받은 객체를 그대로 사용하기 때문에 메소드가 객체의 속성값을 변경하면 메소드 수행 후 변경된 속성값이 그대로 유지



# 상속

클래스 상속 extends 를 이용

자식클래스 extends 부모클래스

```
public class Cat extends Animal{

}
```

Cat 클래스는 Animal 클래스를 상속하게 되었다.

```
package myjava;
public class Cat extends Animal {
    public static void main(String[] args) {
        Cat cat = new Cat();
        cat.setName("catt");
        System.out.println(cat.name);
    }
    
}
```

catt 

자식 클래스에 다른 메소드를 더 추가해서 부모클래스의 기능에 더하여 더 많은 기능을 갖도록 설계한다.

```
.public class Cat extends Animal {
    public void sleep() {
        System.out.println(this.name+" zzz");
    }

    public static void main(String[] args) {
        Cat cat = new Cat();
        cat.setName("Catt");
        System.out.println(cat.name);
        cat.sleep();
    }
}
```



Catt
Catt zzz



IS-A관계

Cat클래스는 Animal클래스를 상속받았다. cat은 Animal에 포함되기 때문에 고양이는 동물이다 라고 표현할 수 있다.

  Cat is a Animal 이라고 말할 수 있는 관계를 IS-A관계 라고 한다.

이 관계에 있을 때 자식 객체는 부모 클래스의 자료형인 것 처럼 사용할 수 있다.

```
Animal cat = new Cat(); // 고양이 클래스로 만든 객체는 동물 자료형이다.
```







하지만 이 반대는 불가

```
Cat cat = new Animal(); // 동물 클래스로 만든 객체는 고양이 이다. > No
```



* 자바에서 만드는 모든 클래스는 Object라는 클래스를 상속받게 되어있다. 우리가 만드는 Animal 클래스는 다음과 기능적으로 완전히 동일하다. 하지만 굳이 아래 코드처럼 Object 클래스를 상속하도록 코딩하지 않아도 자바에서 만들어지는 모든 클래스는 Object 클래스를 자동으로 상속받게끔 되어있다.

```
public class Animal extends Object {
    String name;

```

따라서 자바에서 만드는 모든 객체는 Object 자료형으로 사용할 수 있다.

```
Object animal = new Animal;
Object cat = new Cat;
```

다중상속이 안됨 -> 추상화 인터페이스 를 이용



유효범위 scope 

메소드 안에서 선언되면 그 메소드 안에서만 유효함. 

 static : 정적변수 메모리공간에 올라갈때 바로 사용할 수 있도록

메모리에 올리는 영역에 대한..

#### class밑에 있는 변수 직속 변수 : 전역변수

```
package myjava;
public class ScopeDemo3 {
    static int i=0; //i는 클래스의 변수, 실행되는 순간 사용 가능 
     
    static void a() {
      i=0; // 클래스 메소드에 0을 넣어주는 것
    } 
 
    public static void main(String[] args) { //바로 사용가능
        for (i = 0; i < 5; i++) {
            a(); // a메소드를 호출 
            System.out.println(i);
        }
    }// i에 계속 0을 넣어줘서 무한루프
 
}
```



(int 가 없으면 선언하지 않은것)

전역변수로 선언하면 클래스 내에서 다 사용가능

선언하지 않고 할당만 함



```
package myjava;
public class ScopeDemo3 {
    static int i=0; //i는 클래스의 변수
     
    static void a() {
       int i=0; //선언을 해줌으로서 메소드 안에서i 가 0 이라는 것
    }
 
    public static void main(String[] args) {
        for (i = 0; i < 5; i++) {
            a(); // a메소드를 호출 
            System.out.println(i);
        }
    }
 
}
```

```
package myjava;
public class ScopeDemo3 {
    static int i=0; //i는 클래스의 변수
     
    static void a() {
        i=0; // int 가 없으면 다시 선언하지 않은 것. 여기서는 다시 선언함
    }
 
    public static void main(String[] args) {
        for (int i = 0; i < 5; i++) { // for문안에서 변수를 선언해줘도됨
            a(); // a메소드를 호출 
            System.out.println(i);
        }
    }
 
}
```



#### 메소드 내부에서 선언된 변수: 지역변수



같은 변수더라도 메소드안에서 선언하면 다른것이다. 

무조건 밖에서 선언한다고 해서 같은게 아님 안에서 또 선언 할 수 있다.

for문 안에 선언하면 for 문 안에서만 사용가능!

부모는 자식의 변수를 사용할 수 없음.



정적인유효범위 static scope / lexical scope

메소드를 누가 호출했는지는 상관이 없다.



동적인 유효범위 dynamic scope

인스턴스 , this 의 의미

this : 인스턴스 자체를의미한다. 전역의 의미를 갖게된다



```
package myjava;
   
public class ScopeDemo4 {
    static String title = "";
    static void a(){
         int title = "coding everybody"; //확인용 
         System.out.println(title);
                
    }
    public static void main(String[] args) {
        a();
        System.out.println(title);
    }// 지역변수로만 넣어줘서 메소드안에서만 값이 출력
 
}
```

coding everybody



```
package myjava;
   
public class ScopeDemo4 {
    static String title = "";
    static void a(){
         title = "coding everybody";
                System.out.println(title);
                
    }
    public static void main(String[] args) {
        a();
        System.out.println(title);
    }
 
}// 원래 선언된값에다가 넣어줘서 두번 출력
```

coding everybody

coding everybody





#### this  

그 클래스 자체를 나타내는 전역변수  

클래스의 변수, 메서드를 사용하고 싶을때 사용

```

```

```
class C2 {
    int v = 10;
 
    void m() {
        int v = 20;
        System.out.println(v);
    }
}
 
public class ScopeDemo8 {
 
    public static void main(String[] args) {
        C2 c1 = new C2();
        c1.m();
    }
 
} //20을 출력
```

```
class C3 {
    int v = 10;
 
    void m() {
        int v = 20;
        System.out.println(this.v);
    }
}
 
public class ScopeDemo9 {
 
    public static void main(String[] args) {
        C3 c1 = new C3();
        c1.m();
    }
 
}this 는 해당 클래스를 나타냄 10 출력
```





# 초기화



이전의 메소드를 호출해서 넣어주는 방법

```
Calculator c1 = new Calculator();
c1.setOprands(10, 20); // 객체를 생성하고 
값을 넣어주는 메소드를 호출해서 넣어줌.
c1.sum();       
c1.avg();   
```

->호출하여 넣어주는 과정을 하기 전에 sum 과 avg를 호출한다면 원하는 값을 얻지 못함

-> 불편, 오류



#### 생성자

클래스명과 동일하고 리턴 자료형이 없는 메소드 를 생성자 라고 한다.

변수명은 꼭 의미있게. 중복을 써야하는 경우가 있기 때문에 this 주로 씀

```
class Calculator {
    int left, right;
 
    public Calculator(int left, int right) {
        this.left = left; // 지역변수를 전역변수에 바로 넣어주기
        this.right = right;
    }
 
    public void sum() {
        System.out.println(this.left + this.right);
    }
 
    public void avg() {
        System.out.println((this.left + this.right) / 2);
    }
}
 
public class CalculatorDemo1 {
 
    public static void main(String[] args) {
 
        Calculator c1 = new Calculator(10, 20); //선언과 동시에 값을 넣을 수 있다.
        c1.sum();
        c1.avg();
 
        Calculator c2 = new Calculator(20, 40);
        c2.sum();
        c2.avg();
    }
 
}
```

```
public void(int a, int b) {
left = a;
right= b;
}
//로 할 수 있음. 즉 변수가 겹쳐지는 경우에서 지역변수를 먼저 선택하기때문에 그걸 막기위해 변수를 바꿔준다면 가능
```

//적당한 단위로 객체를 쪼개는 것도 중요. 전역변수 많이 사용하는 것은 좋지 않다.

매개변수를 사용하는 것이 공식적인 방법

값을 사용자가 직접 바꾸는 것은 옳지않음. 메소드를 이용해야함. 오류확인. 외부 접근 제한



인스턴스가 생성될 때 인자 값을 넣어달라고 강제한다면 사용자가 값을 잊지않고 넣도록 도울 수 있다.





- 생성자의 특징

  값을 반환하지 않는다. 인스턴스 생성을 해주는 특수한 메소드.

  생성자의 이름은 클래스의 이름과 동일하다.



# static

모든 메소드, 변수 등은 무조건 메모리에 올라가야만 사용할 수 있다. 메모리에 올라가 있지 않다면 사용할 수 없다. 그렇기 때문에 프로그램이 로딩될 때 힙메모리에 static 영역에 올려주어서 객체 생성전에 호출 가능하게 만드는 것이다. 

즉, 객체를 생성하지 않아도 사용가능하게 함. 공통으로 사용할 수 있게 함. 모든 객체가 공유하는 정보에 주로 쓰임

#### static 메소드

>  인스턴스를 만들지 않아도 클래스 명으로 직접 호출해서 사용할 수 있는 메소드

* static 메소드는 static 변수만 사용할 수 있다.

* 정적메소드는 this를 사용할 수 없다. 참조할 인스턴스 변수가 아직 메모리에 올라가지 않은 상태이기 때문이다. 

* 인스턴스 명으로 static 메소드 호출 가능 

* 클래스 명으로 static 메소드 호출 가능

  

붕어빵 틀 = class

붕어빵 = 인스턴스 들



붕어빵 틀의 스테틱 메소드 :기본 가격 알아내는 , 겉모양알아내는, 겉 재료 알아내는 메소드

붕어빵 틀의 스테틱 변수 : 가격 겉모양 겉재료



#### 상속과 생성자

-------------------------

부모클래스와 자식클래스의 관계

자식클래스 extends 부모클래스

->부모클래스 ⊆ 자식클래스, 자식클래스는 부모클래스 타입

```
package myjava;
class Calculator111 {
    int left, right;
 
    public Calculator111(int i, int j) {
        // TODO Auto-generated constructor stub
    }

    public Calculator111() {
        // TODO Auto-generated constructor stub
    }

    public void setOprands(int left, int right) {
        this.left = left;
        this.right = right;
    }
 
    public void sum() {
        System.out.println(this.left + this.right);
    }
 
    public void avg() {
        System.out.println((this.left + this.right) / 2);
    }
}
 
class SubstractionableCalculator111 extends Calculator111{
    
    public SubstractionableCalculator111(int left, int right) {
        this.left = left;  
        this.right = right;
    }
 
    public SubstractionableCalculator111() {
        // TODO Auto-generated constructor stub
    }

    public void substract() {
        System.out.println(this.left - this.right);
    }
}
 
public class CalculatorConstructorDemo4 {
    public static void main(String[] args) {
        SubstractionableCalculator111 c1 = new SubstractionableCalculator111(10, 20); // 자식 개체 생성
        Calculator111 c2 = new Calculator111(); // 부모 개체를 생성
        Calculator111 c5 = new SubstractionableCalculator111(); // 자식 객체는 부모 클래스의 자료형인 것처럼 사용 가능 
        SubstractionableCalculator111 c5 = new Caculator111(); //부모 객체를 자식 클래스의 자료형인 것처럼 사용 불가능 ->오류
        Calculator111 c3 = c1; //부모클래스에 자식클래스를 넣을 수 있다. 하지만 이때 자식이 갖고 있는 메소드를 사용하지 못하게 됨
        
         
        c1.substract(); // 가능
        c3.substract(); // 불가능 자식식클래스의 메소드는 사용할 수 없다. 
        
        //c1.substract();
    }
}
```



#### 생성자 



1. 객체를 선언해줌.  자동으로 기본 생성자가 생김

```
public class ConstructorDemo {
    public static void main(String[] args) {
        ConstructorDemo  c = new ConstructorDemo();
    }
} /
```



2.오류 / 객체를 선언해줌 . 기본  생성자가 생기지 않음 매개변수를 넣어야하는 생성자가 있기 때문

```
public class ConstructorDemo {
    public ConstructorDemo(int param1) {}
    public static void main(String[] args) {
        ConstructorDemo  c = new ConstructorDemo();
    }// 존재하지 않는 생성자를 호출하고 있다. 
}
```

3. 인자가 없는 기본 생성자를 명시적으로 선언해주어야한다.

```
public class ConstructorDemo{


	public ConstructorDemo(){} //인자가 없는 기본 생성자를 만들어주면 에러 발생 x
	public ConstructorDemo(int param1){}// 매개변수가 있는 생성자가 있을 때는 자동으로 생성자를 만들어주지 않는다. 존재하지 않는 생성자를 호출하고 있다.
	
	public static void main(String[] args){
		ConstructorDemo c = new ConstructorDemo();// 기본생성자에 접근. 기본생성자가 안생겼기 때문에 직접 만들어 줌

}
	}
}
```



#### 



(정상코드)

```
class Calculator {
    int left, right;
 
    public void setOprands(int left, int right) {
        this.left = left;
        this.right = right;
    }
 
    public void sum() {
        System.out.println(this.left + this.right);
    }
 
    public void avg() {
        System.out.println((this.left + this.right) / 2);
    }
}
 
class SubstractionableCalculator extends Calculator {
    public SubstractionableCalculator(int left, int right) {
        this.left = left;  
        this.right = right;
    }
 
    public void substract() {
        System.out.println(this.left - this.right);
    }
}
 
public class CalculatorConstructorDemo4 {
    public static void main(String[] args) {
        SubstractionableCalculator c1 = new SubstractionableCalculator(10, 20);
        c1.sum();
        c1.avg();
        c1.substract();
    }
}
```



-> 매개변수 두개를 받는 생성자를 추가하면 오류가 난다.

```
class Calculator {
    int left, right;
     
    public Calculator(int left, int right){
        this.left = left;// 생성자를 이미 명시적으로 표시.
        //기본생성자가 없어서부모 클래스가 정의되어 있지않다.
        //자바는 기본생성자를 만들어주지 않음
        this.right = right;
    }
     
    public void setOprands(int left, int right) {
        this.left = left;
        this.right = right;
    }
 
    public void sum() {
        System.out.println(this.left + this.right);
    }
 
    public void avg() {
        System.out.println((this.left + this.right) / 2);
    }
}
 
class SubstractionableCalculator extends Calculator {
    public SubstractionableCalculator(int left, int right) {
        this.left = left;
        this.right = right;
    }
 
    public void substract() {
        System.out.println(this.left - this.right);
    }
}
 
public class CalculatorConstructorDemo5 {
    public static void main(String[] args) {
        SubstractionableCalculator c1 = new SubstractionableCalculator(10, 20); 인스턴스 화 시키면 호출하기전에 부모 클래스의 생성자를 자동으로 호출하도록 약속되어있다. 근데 부모클래스를 보면 기본 생성자가 존재하지 않는다. -> 명시적으로 선언해라.
        c1.sum();
        c1.avg();
        c1.substract();
    }
}
```



하위 클래스를 호출시키면 자동으로 상위 클래스의 기본 생성자를 호출하게 된다. 상위 클래스에 생성자가 없을 경우 존재하지 않는 생성자가 호출되므로 에러가난다. 

-> 부모 클래스에 기본 생성자 생성함으로서 해결

```
class Calculator {
    int left, right;
    
    public Caculator(){} //기본 생성자를 넣어줌
     
    public Calculator(int left, int right){
        this.left = left;  
        this.right = right;
    }
     
    public void setOprands(int left, int right) {
        this.left = left;
        this.right = right;
    }
 
    public void sum() {
        System.out.println(this.left + this.right);
    }
 
    public void avg() {
        System.out.println((this.left + this.right) / 2);
    }
}
 
class SubstractionableCalculator extends Calculator {
    public SubstractionableCalculator(int left, int right) {
        this.left = left;     
        this.right = right;
    }
 
    public void substract() {
        System.out.println(this.left - this.right);
    }
}
 
public class CalculatorConstructorDemo5 {
    public static void main(String[] args) {
        SubstractionableCalculator c1 = new SubstractionableCalculator(10, 20);
        c1.sum();
        c1.avg();
        c1.substract();
    }
}
```



중복이 발생. 코드가 많아지고 유지보수가 어려워짐 

```
class Calculator {
    int left, right;
    
    public Caculator(){}
    
    public Calculator(int left, int right){
        this.left = left;
        this.right = right;
    }
     
    public void setOprands(int left, int right) {
        this.left = left;
        this.right = right;
    }
 
    public void sum() {
        System.out.println(this.left + this.right);
    }
 
    public void avg() {
        System.out.println((this.left + this.right) / 2);
    }
}
 
class SubstractionableCalculator extends Calculator {
    public SubstractionableCalculator(int left, int right) {
        this.left = left;
        this.right = right;//생성자   -> 중복이 있으면 코드가 많아지고 유지보수어려워짐 -> 중복을 없애기 위해 Super 사용.
    }
 
    public void substract() {
        System.out.println(this.left - this.right);
    }
}
 
public class CalculatorConstructorDemo5 {
    public static void main(String[] args) {
        SubstractionableCalculator c1 = new SubstractionableCalculator(10, 20);
        c1.sum();
        c1.avg();
        c1.substract();
    }
}
```





상위 하위가 동일한 생성자를 갖고 있다. 동일한 일을 하고 있다? -> 중복 여러가지 문제가 생김

//하위 클래스에서 상위 클래스의 생성자와 같은 역할을 하는 생성자가 필요한데.. 이걸 또 넣어주지 않고 하는  방법이 있다.

# super

상위 클래스를 가리키는 키워드



생성자가 같다면 중복이 생김.-> 해결

```
package myjava;
class Calculatorr {
    int left, right;
    
    
    public Calculatorr(int left, int right){// 정수 두개를 받는 이 생성자가 호출
        this.left = left;
        this.right = right; 
    }
    
    
    public void setOprands(int left, int right){
        this.left = left;
        this.right = right;
    }
    
    
    public void sum(){
        System.out.println(this.left+ this.right);
    }
    
    public void avg(){
        System.out.println((this.left+this.right)/2);
    
    }
}

class Substraction extends Calculatorr{
    public Substraction(int left, int right){
        super(left, right);
    } //매개변수의 값이 슈퍼 클래스의 안으로 들어감
    //상위 클래스의 생성자를 하위 클래스에서 호출해서 실행할 수 있게해준다.
    //this가 자기자신 이였다면 super는 부모
    public void substract(){
        System.out.println(this.left - this.right);
        
    }
}

    public class CalculatorConstructorDemo5{
        public static void main(String[] args){
            Substraction c1 = new Substraction(10,20);// 전달 해줌
            c1.sum();
            c1.avg();
            c1.substract();
        }
    } 
```

결론 부모의 기본 생성자를 우선 호출해주어야 함 . 내가 작업해놓은 생성자를 명시적으로 호출시켜줌으로서 기본 생성자를 호출하지 않아도 되게 해줌

상속을 받은 자식 클래스는 생성하자마자 부모의 클래스의 생성자를호출하도록 되어있다. 이 때 부모클래스의 생성자에 매개변수가 존재한다면 그것을해결할 방법 두가지

1. 부모의 생성자에 기본 생성자를 생성.

2. 자식 클래스의 생성자안의 부모클래스의 매개변수 생성자인 super(매개변수); 선언

   주의점 : super(매개변수);는 자식 클래스의 생성자 안에서 가장 처음 존재해야한다.....





# 오버라이딩

창의적인 상속, 재 정의하는 것, 

기존의 부모의 메소드를 덮어쓰기를 통해 기능을 변경한 자식만의 메소드

부모 클래스의 메소드기능에 새로운 기능을 덮어쓰기 해서 독자적 정의를하는 것

부모와 자식에 같은 이름의 메소드가 있다면 자식 클래스의 메소드가 실행된다.

```
package org.opentutorials.javatutorials.overriding.example1;
 
class Calculator {
    int left, right;
 
    public void setOprands(int left, int right) {
        this.left = left;
        this.right = right;
    }
 
    public void sum() {
        System.out.println(this.left + this.right);
    }
 
    public void avg() {
        System.out.println((this.left + this.right) / 2);
    }
}
 
class SubstractionableCalculator extends Calculator {
     
    public void sum() {
        System.out.println("실행 결과는 " +(this.left + this.right)+"입니다.");
    }// 부모가 이미 갖고 있는 메소드를 재 정의
     
    public void substract() {
        System.out.println(this.left - this.right);
    }
}
 
public class CalculatorDemo {
    public static void main(String[] args) {
        SubstractionableCalculator c1 = new SubstractionableCalculator();
        c1.setOprands(10, 20);
        c1.sum();
        c1.avg();
        c1.substract();
    }
}
```

실행 결과는 30 입니다.

15

-10



![image-20200728125837401](C:\Users\rey\AppData\Roaming\Typora\typora-user-images\image-20200728125837401.png)

부모 클래스에서 sum 정의 : 모든 클래스 들의 기본적인 동작방법 정의 공통분모 정의 / 넓게

하위 메소드에서 sum 정의 : 부모 클래스의 sum보다 더 높은 우선순위.  /우선 순위





출력하는 메소드를 리턴해주는 메소드로 오버라이딩 하면?

```
class Calculator {
    int left, right;
 
    public void setOprands(int left, int right) {
        this.left = left;
        this.right = right;
    }
 
    public void sum() {
        System.out.println(this.left + this.right);
    }
 
    public void avg() {
        System.out.println((this.left + this.right) / 2); //평균 값 출력
    }
}
 
class SubstractionableCalculator extends Calculator {
     
    public void sum() {
        System.out.println("실행 결과는 " +(this.left + this.right)+"입니다.");
    }
     
    public int avg() {
        return (this.left + this.right)/2; // int 값 리턴
    }
     
    public void substract() {
        System.out.println(this.left - this.right);
    }
}
 
public class CalculatorDemo {
    public static void main(String[] args) {
        SubstractionableCalculator c1 = new SubstractionableCalculator();
        c1.setOprands(10, 20);
        c1.sum();
        c1.avg();
        c1.substract();
    }
}
```

-> 하위 클래스의 메소드의 리턴 타입이 부모 클래스의 리턴타입과 호완되지 않아 오류

-> 리턴값이 불일치 하는 경우 안됨 



주의점 : 

-> 메소드의 이름, 리턴형, 메소드의 매개변수의 갯수, 데이터 타입, 그리고 순서, 메소드의 리턴타입

:= 메소드의 서명 시그니처가 일치해야한다.





해결?

부모의 메소드를 자식 메소드와 같게 고쳐주기... 

```
 
class Calculator {
    int left, right;
 
    public void setOprands(int left, int right) {
        this.left = left;
        this.right = right;
    }
 
    public void sum() {
        System.out.println(this.left + this.right);
    }
 
    public int avg() { // 자식 클래스의 메소드와 같게 고쳐주기
        return (this.left + this.right) / 2;
}
 
class SubstractionableCalculator extends Calculator {
     
    public void sum() {
        System.out.println("실행 결과는 " +(this.left + this.right)+"입니다.");
    }
     
    public int avg() {
        return (this.left + this.right)/2;
    }
     
    public void substract() {
        System.out.println(this.left - this.right);
    }
}
 
public class CalculatorDemo {
    public static void main(String[] args) {
        SubstractionableCalculator c1 = new SubstractionableCalculator();
        c1.setOprands(10, 20);
        c1.sum();
        c1.avg();
        c1.substract();
    }
}
```



하지만 부모의 수정 없이 상속받는 것이 목적이기 때문에 좋은 방법은 아님, 중복 도 생김 -> 유지보수, 가독성 낮아짐..

코드의 중복은 최대한 제거해야하는 존재



-> super를 써서 해결하기 

```
class Calculator {
    int left, right;
 
    public void setOprands(int left, int right) {
        this.left = left;
        this.right = right;
    }
 
    public void sum() {
        System.out.println(this.left + this.right);
    }
 
    public int avg() {
        return ((this.left + this.right) / 2);
    }
}
 
class SubstractionableCalculator extends Calculator {
     
    public void sum() {
        System.out.println("실행 결과는 " +(this.left + this.right)+"입니다.");
    }
     
    public int avg() {
        return super.avg(); // 상위 클래스의 메소드를 호출하기 위해 super를 썼다.
    }
     
    public void substract() {
        System.out.println(this.left - this.right);
    }
}
 
public class CalculatorDemo {
    public static void main(String[] args) {
        SubstractionableCalculator c1 = new SubstractionableCalculator();
        c1.setOprands(10, 20);
        c1.sum();
        System.out.println("실행 결과는" + c1.avg());
        c1.substract();
    }
}
```

실행 결과는 30입니다.
실행 결과는15
-10

```
public int avg(){
	return super.avg(); //부모의 메소드를 호출
}//뒤에 더 추가해도 됨 
```



# overloading

같은 이름이지만 서로다른 매개변수의 형식을 갖고 있는 메소드를 여러개를 정의 하기 위한 방법

사용자는 별도로 기억할 필요 없이 하나의 이름의 메소드에 값을 갯수에 상관 없이 넣을 수 있음

```
c1.setOprands3(10,20,30);
c1.setOprands2(10,20);
```

//둘 다 값을입력 받는 메소드 이지만 매개변수를 3개 받아야하는 메소드에서 두개를받거나 그 반대의 경우 오류가 난다. 

-> 다른 이름으로 다 지정해주어야 한다.

똑같은 동작방법을 갖고 있지만 매개변수가 달라지는 이유로 인해 달라져야 한다.

한가지 이름의 메소드에 매개변수 갯수를 다르게하여 넣는 방법이 있을까 ,



해결? 오버로딩

```
 
class Calculator{
    int left, right;
    int third = 0; //새로지정 두개의 값만 들어갔을 때는 0이 되게..
      
    public void setOprands(int left, int right){
        System.out.println("setOprands(int left, int right)");
        this.left = left;
        this.right = right;
    }
     
    public void setOprands(int left, int right, int third){
        System.out.println("setOprands(int left, int right, int third)");
        this.left = left;
        this.right = right;
        this.third = third;
    }
     
    public void sum(){
        System.out.println(this.left+this.right+this.third);
    }
      
    public void avg(){
    	
        System.out.println((this.left+this.right+this.third)/3);
    }
}
  
public class CalculatorDemo {
      
    public static void main(String[] args) {
          
        Calculator c1 = new Calculator();
        c1.setOprands(10, 20);
        c1.sum();       
        c1.avg();
        c1.setOprands(10, 20, 30);
        c1.sum();       
        c1.avg();
         
    }
  
}
```

같은 이름 ( 다른 매개변수)

자바에선 이름이 같더라도 매개변수의 형식, 갯수가 다르다면 다른 메소드로 인식한다

-> 이름을 다 다르게 지정해줘야하는 수고로움이 사라짐, 사용자 입장에서도 혼동 없이 사용가능

하지만 중복이 생김



-> 중복이 되는 코드를

```
 
class Calculator{
    int left, right;
    int third = 0;
      
    public void setOprands(int left, int right){
        System.out.println("setOprands(int left, int right)");
        this.left = left;
        this.right = right;
    }
     
    public void setOprands(int left, int right, int third){
        System.out.println("setOprands(int left, int right, int third)");
        this.setOprands(left,right)// 중복이되는 메소드를 먼저 호출해서 중복제거
        this.third = third;//추가로 필요한 부분만 부가->재활용,중복제거.유지보수편의성
    }
     
    public void sum(){
        System.out.println(this.left+this.right+this.third);
    }
      
    public void avg(){
        System.out.println((this.left+this.right+this.third)/3);
    }
}
  
public class CalculatorDemo {
      
    public static void main(String[] args) {
          
        Calculator c1 = new Calculator();
        c1.setOprands(10, 20);
        c1.sum();       
        c1.avg();
        c1.setOprands(10, 20, 30);
        c1.sum();       
        c1.avg();
         
    }
  
}
```



같은 매개변수(갯수, 타입)를 갖고 있는 메소드가 리턴값이 다르면 오버로딩이 아니라 오류

매개변수가 존재하지 않는 두개의 메소드도 리턴값이 다르면 오류 있을때



자바는 누구를 호출 한 것인지 모름. 리턴값을 뭘 원하는지 모름



오버로딩 : 같은 이름.  다른 메소드

오버라이딩 : 부모클래스의 메소드의 이름과 매개변수 형식 갯수가 동일한 메소드를 다시 재정의



오버라이딩 : 부모 클래스의 메소드와 이름, 변수 갯수, 타입, 리턴 값의 타입

오버로딩 :  메소드 끼리 이름, 리턴값의 타입이 같아야 하고 매개변수의 표현형, 갯수는 상관 없다.

(매개변수의 이름은 상관없음)

반환값은 메소드를 사용한 결과 -> 에러를 발생



# 클래스 패스

>  자바 가상머신이 클래스 파일을 찾는 경로
>
>  클래스가 위치하는 경로를 지정하여 자바가 필요로 하는 클래스를 로드해줌

my.java 파일 생성

```
class Item{
}
 
class ClasspathDemo {
} 
```



>  터미널에서 cd로 현재 디렉토리로 이동 후
>
> dir로 파일 목록확인
>
> javac my.java 로 컴파일
>
> 확장자가 class인 ITem, ClasspathDemo파일이 생성된다. 

 

-> 소스코드 안에 클래스 갯수만큼 클래스 파일이 만들어짐. 

* 이 클래스 파일들은 그 클래스와 관계된 파일이 컴파일 될 때 사용되야 한다.

* 사용되는 클래스들이 모두 같은 디렉터리 안에 있어야 오류 안남( 따로 지정하지 않았을 경우)

* 다른 곳에 있다면  누락된 클래스가 위치하고 있는 곳을 클래스 패스로 알려줌



 ```java -classpath".;lib" Classpathdemo2 ```

* ;  경로와 경로를 구분해주는 구분자

* .  현재 디렉터리 에서 클래스를 찾는다

  -> 현재 디렉토리를 먼저 찾아보고 없다면 그 밑에있는 립 디렉토리에서 찾아봐라

```java -classpath"lib" Classpathdemo2```

lib 디렉토리 안에서만 찾아봐라.





#### 환경변수

>  운영체제에 지정하는 변수 / 어디에 있건 간에 접근할 수 있는 변수
>
>  어떤 경로에서라도 자바를 실행하고자 하기 위함.



* 컴파일을 할 때마다 클래스 패스를 지정하는 것은 번거롭다 -> 환경변수를 이용

* 자바 가상머신과 같은 어플리케이션 들은 환경변수의 값을 참고해서 동작

* 자바는 클래스 패스로 환경변수 CLASSPATH를 사용하는데 이 값을 지정하면 실행할 때 마다 설정시켜주지 않아도 됨. -> 최신 버전 자바는 직접 잡아줌

  -classpath 옵션을 사용하지 않아도 되기 때문에 편리하다. 하지만 운영체제를 변경하면 클래스패스가사라지기 때문에 이식성면에서 불리할 수 있음



사용자 변수? 시스템 변수?

* 사용자 변수는 현재 windows에 접속한 사용자에 대해서만 설정을 하는것
* 시스템 변수는 사용자의 관계 없이 모든 사용자에게 적용을 한다.



# 패키지

> 자바 클래스 들을 여러 이름공간으로 정리. 클래스들의 묶음 (폴더같은 기능)
>
> 클래스 이름이 동일해도 패키지가 다르면 다른 클래스로 인식하기 때문에 하나의 클래스 안에서 같은 이름의 클래스를 사용할 수 있다.
>
> 패키지 이름 + 클래스 이름 : 클래스를 유일하게 만들어주는 식별자 역할. 다른 디렉터리에 저장한다면 하나의 컴퓨터 안에 같은 이름의 파일이 공존 할 수 있다.



패키지 명은 보통 그 폴더의 경로.

```
F:\dropbox\생활코딩\실습\java_tutorials\src\org\opentutorials\javatutorials\object\CalculatorDemo4.java
```

->src 가 프로젝트 최상위 경로

```
package org.opentutorials.javatutorials.object;
```

> 패키지 명은 일반적으로 클래스를 제작한 개인이나 단체가 소속된 웹사이트의 도메인을 이용한다. 웹사이트 고유의 도메인을 씀으로서 중복의 문제를 피할 수 있다. 역순으로 사용.



* 패키지 이름 작성 규칙
  * 숫자로 시작 X,   $와 _를 제외한 특수문자 X
  * java로 시작하는 패키지는 자바 표준 API에서만 사용하므로 사용 X
  * 모든 글자는 소문자로 작성
  * import 패키지명. : 패키지 안의 모든 클래스를 가져올 수 있다. -> 오류가 날 수도 있음



* import /  같은 패키지가 아니면 로드할 수 없다. -> 다른 패키지의 클래스를 가져온다.

  * import 패키지명.* : 패키지 안의 모든 클래스를 가져올 수 있다. -> 오류가 날 수도 있음

  * import 패키지명.클래스  : 패키지안의 클래스를 가져온다
  * 패키지 안에 또 다른 패키지가 있을 수 있음

  



그럼 다른 패키지 안의 같은 이름의 파일들을 구분하는 법은?

```
package org.opentutorials.javatutorials.packages.example3;
import org.opentutorials.javatutorials.packages.example1.*;
import org.opentutorials.javatutorials.packages.example2.*;
 
public class D {
    public static void main(String[] args) {
        org.opentutorials.javatutorials.packages.example2.B b = new org.opentutorials.javatutorials.packages.example2.B();
    }
}
// 패키지명.클래스명을 해주면 특정 패키지에 있는 클래스를 나타낼 수 있음
  
```





# api, api 문서 보는법

```
System.out.println(1);
```

>  println은 PrintSteam 이라는 클래스의 메소드 이다.  하지만 이를 System 클래스에서 쓰기 위해서 out이라는 변수를 생성하여 사용했다.  PrintStream out = new PrintStream();

* println() : 괄호안의 정보를 출력하는 메소드

* System : 클래스, 대문자로 시작해야하는 네이밍 규칙

* out : 시스템 클래스의 맴버 중 하나인 변수. 이 변수는 프린트 메소드를 갖고 있는 객체

(static 메소드에서 static 변수를 접근할 수 있다. )

-> println은 System의 소속이 아니라 out이라는 변수안에 있는 객체가 갖고 있는 메소드

>  System.out을 쓸 때 System 클래스에서 인스턴스화 시키지 않았다. 
>
> 이는 out 이 System클래스의 클래스 변수(static)이라는 것을 알 수 있다.



http://docs.oracle.com/javase/

java.lang 패키지의 System 클래스 / 클래스 맴버 확인 가능

fields 

err, in, out 필드의 이름 정적 변수/ 

printStream 그 변수의 데이터 타입 , 변수에 담겨져 있는 것 printStream 이라는 클래스

printSteam 클래스의 메소드 기능들을 확인 할 수 있다.

매개변수에 따라 다른 작용을하는 같은 이름의 메소드 들 ( 오버로딩 )



### API

application programming interface

시스템과 시스템을 제어하는 주최 사이의 접점에 해당하는 조작방법

어떻게 출력기능을 구현하는지는 모르지만 명령을 통해 그 기능을 사용할 수 있다.

우리가 프로그램을만들때 쓰는 코드의 형태를 띄고 있는 인터페이스

### UI

UI user interface / TUI GUI 

중계자.  접점. 입력장치, 출력장치 등 시스템이 사용자를 대면하는 접점 

사용자의 의중을 시스템에 전달,  시스템의 상태를 사용자에게 보여준다.





# 접근 제어자

> **권한**에 차등을 두는 것. 협업을 하게 되었을 때 자유만 있다면 여러 문제가 생길 수 있다.
>
> -> 규제를 둠
>
> 변수의 데이터 타입이나, 리턴타입이나.. 등등 
>
> 추상클래스, final, 접근 제어자, 인터페이스 등등  자바는 객체지향 언어기때문에 더 중요
>
> 더 문제없이. 자유롭게 프로그래밍 하기 위한 것임.



* public  누구든 그 클래스의 메소드를 사용할 수 있다.

* private 이면 클래스 내부에서만 사용가능하다. 외부에서 사용하라하면 오류



```

class A {
    public String y(){
        return "public void y()";
    }
    private String z(){
        return "public void z()";
    }
    public String x(){
        return z();
    }
}
public class AccessDemo1 {
    public static void main(String[] args) {
        A a = new A();
        System.out.println(a.y());
       
        //System.out.println(a.z()); : z의 접근 제어자가 private 이기 때문에 오류. 보이지도 않음
        System.out.println(a.x()); //x 메소드가 호출되고 내부적으로 메소드 z를 호출하고 있기 때문에 메소드 z는 정상적으로 호출된다. 왜냐면 메소드 x와 z는 같은 클래스 소속이기때문
    }
}
```

>  은행으로 비유하면  고객 :  AccessDemo1, public : 창구 x, private : 금고 z 



-> 사용자는 사용하도록 의도되어있는 것들만을 사용하게 된다.



|                             | public | protected | default  | private  |
| --------------------------- | ------ | --------- | -------- | -------- |
| 같은 패키지, 같은 클래스    | 허용   | 허용      | 허용     | 허용     |
| 같은 패키지, 상속 관계      | 허용   | 허용      | 허용     | **불용** |
| 같은 패키지, 상속 관계 아님 | 허용   | 허용      | 허용     | **불용** |
| 다른 패키지, 상속 관계      | 허용   | 허용      | **불용** | **불용** |
| 다른 패키지, 상속 관계 아님 | 허용   | **불용**  | **불용** | **불용** |

![img](https://s3.ap-northeast-2.amazonaws.com/opentutorials-user-file/module/516/1996.jpg)

>  protected 는 다른 패키지라도 상속받으면 접근 가능



#### 클래스의 접근 제어자

* public : 다른 패키지의 클래스에서도 사용 가능

* default : 같은 패키지 에서만 사용 가능 (아무것도 안붙히는거랑 같음)



```
package org.opentutorials.javatutorials.accessmodifier.inner;
public class PublicClass {}
```

> inner 로 끝나는 패키지에 public형으로 지정되어있다.



```
package org.opentutorials.javatutorials.accessmodifier.inner;
class DefaultClass {}
```

> inner 로 끝나는 패키지에 default형으로 지정되어 있다. 

```
package org.opentutorials.javatutorials.accessmodifier.inner;
public class ClassAccessModifierInnerPackage {
    PublicClass publicClass = new PublicClass();
    DefaultClass defaultClass = new DefaultClass();
} // 둘다 inner 안에 있는 클래스 이므로 사용 가능
```

```
package org.opentutorials.javatutorials.accessmodifier.outter;
import org.opentutorials.javatutorials.accessmodifier.inner.*;
public class ClassAccessModifierOuterPackage {
    PublicClass publicClass = new PublicClass();
    //DefaultClass defaultClass = new DefaultClass();
} 같은 패키지의 클래스에서만 사용이 가능하기 때문
```



public 을 쓸때 제약사항

* 반드시 소스코드의 이름은 퍼블릭 클래스의 이름하고 동일해야한다.
* 하나의 소스코드안에는 public 클래스가 하나만 존재해아한다.





# Abstract

> 상속을 강제하는 일종의 규제,
>
> abstract class 추상 클래스 , abstract method명 추상 매서드

```
package myjava;
abstract class A{
    public abstract int b(); //추상 메소드 상속 받아서 새로 정의해 주어야 함
    
    public void d() {
        System.out.println("world");// 추상 클래스에는 추상 메소드가 아닌 기본 메소드가 존재할 수 있다.
    }
}


public class AbstractDemo{
    public static void main(String[] args) {
        A obj = new A();
       
    }
}
```

-> 오류가 남. A는 abstract 추상 클래스이므로 인스턴스 화 하면 오류가 발생한다.

추상 클래스는 구체적인 메소드의 내용이 존재하지 않음.  인스턴스화 시켜서 사용할 수 없다. 





> 해결. 추상 클래스의 상속

```
package myjava;
abstract class A{ //A는 추상클래스 반드시 상속해서 사용해야함
    public abstract int b(); // {}가 없고 시그니쳐만 있음 -> 반드시 다시 정의해줘야함
    //본체가 있는 메소드는 abstract 키워드를 가질 수 없다.
       
    public void d(){
        System.out.println("world"); //추상 클래스 내에는 추상 메소드가 아닌 메소드가 존재 할 수 있다. 
    }
}

class B extends A {
    public int b() {
    	return 1;
    } // A를 상속받은 B 클래스가 추상 클래스A의 추상 메소드 b를 정의 해줌
}


public class AbstractDemo{
    public static void main (String[] args) {
        //A obj = new A();
       B obj = new B(); // 상속받은 자식 클래스 B 에서 새 인스턴스 객체 obj를 생성
       System.out.println(obj.b()); //obj의 b메소드 호출
       }
}        
        

```

클래스 B는 클래스 A를 상속했다. 그리고 클래스 A의 추상 메소드인 b를 오버라이딩 하여 클래스 A를 사용할 수 있었다.



> 부모클래스에서 추상 메소드는 본체가 없고 시그니쳐만 있음 . 
>
> 이 메소드를 사용해주기 위해선 상속받은 하위 클래스에서 본체를 다시 정의해주는 과정이 필요하다.
>
> = 구현의 책임을 사용하는 대상에게 넘기는 것



특징

* 담고 있는 메소드 중 하나라도 abstract 면 자동으로 클래스도 abstract가 된다.
* 추상 클래스에는 추상 메소드가 아닌 메소드가 존재할 수 있다



#### 추상 클래스를 사용하는 이유

> 상속을 강제하기 위한 규제. 
>
> 공통적인 기능이 아닌 상황에 따라 동작하는 방법이 달라져야 하는 부분을 사용자에게 위임



덧셈 뺄셈을 계산해내지만 경우에 따라 앞에 +를 붙이거나 - 를 붙이거나 하는 프로그램

```
package myjava;
abstract class Cal {
    int left, right;
    public void setOprands(int left, int right) {
        this.left  = left;
        this.right = right;
        
    }
    public abstract void sum();
    public abstract void avg();
    
    public void run() {
        sum();
        avg();
    }
}

class Calplus extends Cal {
    public void sum(){
        System.out.println("+ sum : "+ (this.left + this.right ));
        
    }
    public void avg(){
        System.out.println("+ avg : "+ (this.left +this.right)/2);
    }
}


class Calmin extends Cal {
    public void sum() {
        System.out.println("- sum : " + (this.left+this.right));
    }
    public void avg() {
        System.out.println("- avg : "+ (this.left + this.right)/2);
    }
}

public class calculation123{
    public static void main(String[] args){
        Calplus CalP = new Calplus();
        CalP.setOprands(10,20);
        CalP.run();
        
        Calmin Calm = new Calmin();
        Calm.setOprands(20,30);
        Calm.run();
        
    }
}

```



중복되는 부분이 생김 -> 유지보수의 문제

```
package myjava;
abstract class Cal {
    int left, right;
    public void setOprands(int left, int right) {
        this.left  = left;
        this.right = right;
    }
     public int summ() {
        return this.left+this.right;
    }
   
    public abstract void sum();
    public abstract void avg();
    
    public void run() {
        sum();
        avg();
    }
}

class Calplus extends Cal {
    public void sum(){
        System.out.println("+ sum : "+ summ());
        
    }
    public void avg(){
        System.out.println("+ avg : "+ summ()/2);
    }
}


class Calmin extends Cal {
    public void sum() {
        System.out.println("- sum : " + summ();
    }
    public void avg() {
        System.out.println("- avg : "+ summ()/2);
    }
}

public class calculation123{
    public static void main(String[] args){
        Calplus CalP = new Calplus();
        CalP.setOprands(10,20);
        CalP.run();
        
        Calmin Calm = new Calmin();
       
        Calm.run();
        
    }
}



```





# final

> 상속/ 변경을 금지하는 규제 / 
>
> 절대 변하지 않는 특정한 것을 정하고 싶을 때

```
package myjava;

class Calculator5 {
    static final double PI = 3.14;
    int left, right;
    
    public void setOprands(int left, int right) {
        this.left = left;
        this.right = right;
        //Calculator.PI = 6; final 값 이므로 변경되는 것이 불가능
    }
    public void sum() {
        System.out.println(this.left+this.right+PI);
    }
}

public class finalaaaa {

    public static void main(String[] args) {
       Calculator5 c1 = new Calculator5();
       c1.setOprands(10,20); 
       //Calculator5.PI =4; 클래스 변수 변경 금지
       //c1.PI =4 ; 인스턴스 변수도 금지
     
      
       System.out.println(c1.left);

    }

}

```

> 클래스 변수와 인스턴스 변수 모두에 적용



##### final 메소드와 final 클래스

> final로 지정해주면 상속이 안됨.

```
package myjava;

class A{
    final void b() {}
    void c() {}
}
class B extends A{
    //void b() {} final 메소드 b 를 상속하려 하기 때문
    void c() {}
}

final class C {
    final void d() {}
}

// class D extends C{} final 클래스 C를 상속하려 하기 때문


public class final2 {

    public static void main(String[] args) {
        

    }

}
```



- final 은 변수, 메소드 클래스에 모두 사용할 수 있다.
- 변수에 사용하면 변하지 않는 상수. 
- 메소드에 사용하면 재정의가 불가능한 메소드.  @@
- 클래스에 사용하면 상속이 불가능한 하나의 완전한 클래스



# 인터페이스

> * 규제 / 어떤 클래스가 있고 그 클래스가 특정한 인터페이스를 사용한다면, 반드시 인터페이스의 메소드들을 구현해야 한다. 
> * 자바 프로그래밍 언어에서 클래스 들이 구현해야 하는 동작을 지정하는데 사용되는 추상 자료형.
>
> * is a 관계가 성립하지 않거나 다중 상속을 하고 싶을 때 사용한다. 
>
> -인터페이스는 변수를 갖지 않는 클래스 이기 때문에 다중상속과 유사한 기능 구현 가능
>
> 
>
> ex) 폴라로이드 카메라 : 프린터 클래스 + 카메라 클래스 -> 카메라 클래스는 상속받고 프린터라는 인터페이스를 사용

```
package myjava;

interface I{
    public void z(); // 인터페이스 I는 z라는 메소드가 구현돼야한다고 규제
}

class A implements I{ //인터페이스 I를 클래스 A가 구현. Z의 역할 구현
    public void z(){} 
}


public class Interfacec {

    public static void main(String[] args) {       
    }
}

```





##### 실직적인 쓰임

계산기 클래스를 만드는데 3개월이 걸린다. 그 클래스를 사용하여야 하는 개발자는   그냥 기달려야함?

-> 가짜 모조 클래스를 정의 해서 메소드를 구현은 하진 않지만 메소드 명과 메소드에 들어가는 매개변수 등을 약속해놓고 각자 동시에 작업 

(A 개발자는 계산기 클래스 / B 개발자는 계산기 클래스를 사용하는 로직)

->3개월 후 구체적 로직이 완성되면 합치면 됨



B 개발자

세개의 변수를 받아서 합과 평균을 구하는 메소드가 있는 클래스를 개발해 주기를 기대하고 그 클래스를 사용하는 로직을 만든다

```
package myjava;

class CalculatorDommy{
    public void SetOprands(int first, int second, int third) {}
    public int sum() {
        return 60;
    }
    public int avg() {
        return 20;
    } //기대하는 값이 반환 되게 임의로 넣어줌
}
public class interb {

    public static void main(String[] args) {
        CalculatorDommy c = new CalculatorDommy();
        c.SetOprands(10,20,30);
        System.out.println(c.sum()+c.avg());

    }

}
```



A 개발자

계산기 기능 구현

```
package myjava;

public class Calculator {
    int left, right;
    public void setOprands( int left, int right) {
        this.left = left;
        this.right= right;
        
    }
    
    public void sum () {
        System.out.println(this.left + this.right);
       
    }
    
    public void avg() {
        System.out.println((this.left+this.right)/2);
    }
    public static void main(String[] args) {
      
    }

}
```

둘이 매개변수가 다른 메소드를 생각했다. 구현 불가

-> 인터페이스로 약속을 정의하자.

입력값을 어떤 형으로 몇개를 받고 어떤 역할을 하는지를 정의 하는 명세서. 개발자 간의 약속이 될 수 있다.

```
public interface Calculatable{
    public void setOprands (int first, int second, int third);
    public sum();
    public avg();
```

B 개발자

```
package myjava;


class CalculatorDummy implements Calculatable{
    public void setOprands(int first, int second, int third){
    }
    public int sum () {
        return 60;
    }
    public int avg() {
        return 20;
    }
       
}
public class inter5 {

    public static void main(String[] args) {
        CalculatorDummy c = new CalculatorDummy();
        c.setOprands(10,20,30);
        System.out.println(c.sum() + c.avg());

    }


```

A 개발자 계산기 프로그램

```
package myjava;


class Calculator1234 implements Calculatable{
    int first, second, third;
    
    
    public void setOprands(int first, int second, int third) {
        this.first =first;
        this.second = second;
        this.third = third;
    }


    public int sum() {
        return this.first+this.second+this.third;

        }

    public int avg() {
        return (this.first+this.second+this.third)/3;

        }
}

```



-> 더미를 실제 로직으로 교체하기

```
package myjava;

interface Calculatable {
    public void setOprands(int first, int second, int third);
    public int sum();
    public int avg();
}
    
class Calculator implements Calculatable{
    int first, second, third;
        
    public void setOprands(int first, int second, int third) {
        this.first =first;
        this.second = second;
        this.third = third;
    }


    public int sum() {
        return this.first+this.second+this.third;

        }

    public int avg() {
        return (this.first+this.second+this.third)/3;

        }

    }
       
public class inter10 {

    public static void main(String[] args){
        Calculator c = new Calculator();
        c.setOprands(10,20,30);
        System.out.println(c.sum() + c.avg());
    }
}

```



# 오류 정리

----------------

Editor does not contain a main type

- 편집기에 기본 유형이 없다? 
- 같은 패키지 안에 같은 이름의 클래스가 이미 있어서 불가능했다.
- import가 되있지 않을 경우도 발생가능
- Scr디렉토리 이외에 위치한 경우에도 발생 가능

##### 인터페이스 규칙

1. 하나의 클래스가 여러 개의 인터페이스를 구현 할 수 있다.

   ```
   package myjava;
   
   interface I1 {
       public void x();
   }
   
   interface I2 {
       public void z();
       
   }
   
   
   class K implements I1, I2 { // I1과 I2의 모든 메소드를 구현해주어야한다.
       public void x() {}
       public void z() {}
   }
   
   ```

   

2. 메소드는 무조건 public , public 을 생략하면 default 가 아니라 public 이 됨

    종속받은 외부의 클래스 들을 조작하기 위해서

```
package myjava;

interface inter11 {
    //private void x(); 오류
    void x();

} 
```





- 인터페이스는 추상 메서드를 포함하고 있는 추상 클래스와 비슷.

-  추상 메서드를 포함하고 있으면 객체 생성이 불가능하므로 자식클래스를 생성 -> 자식 클래스에서 객체를 생성하여 사용하기 때문에 유지 보수가 쉬움

- 상수와 추상 메소드 외에 다른 맴버를 갖지 못하게 함으로서 더욱 더 추상화를 완벽하게함

  

> 추상메소드 ? 함수의 원형은 있는데 그 함수로 뭘 처리해주겠다는 내용이 없는 것 {}X
>
> ```
> public void kindOf(); //{}가 없음
> ```
>
> 추상 메소드는 추상 클래스 내에서만 선언할 수 있다. 일반 클래스에서 추상 메소드를 선언할 수 없다. (추상 메소드가 하나라도 존재하는 클래스는 반드시 추상 클래스가 되어야 한다.)
>
> 추상 클래스는 불완전한 추상 메소드를 포함한 불완전한 클래스 이므로 객체를 만들어 사용할 수 없다. 그래서 추상 클래스를 상속 받은 자식 클래스는 모든 추상 메소드를 override 해서 사용해야한다. 
>
> 추상 클래스와 메소드는 abstract로 표시되어야 한다. 



##### 그럼 인터페이스는 추상 클래스 인가? 아니다

> 인터페이스는 모든 메소드 들이 정의상 추상적이기 때문에 abstract 키워드가 필요하지 않다. 

추상 클래스는 내가 원하는 메소드를 추상 메소드로 선언할 수 있지만 

인터페이스에서는 기본형 변수를 선언하거나, 메소드를 정의해버리면 오류가 난다.

일반 변수를 못갖기 때문에 final 예약어를 이용해서 맴버 변수를 선언해야함

객체를 생성할 수 없으므로 static 을 붙혀 상수 선언

즉, 정적변수나 메소드의 선언만이 올 수 있음. ( abstract가  숨겨져 있긴 하지만 무조건 추상 메소드 이기 때문에 붙일 필요가 없다. )



+ 객체를 사용하지 않고 인터페이스 이름으로 직접 해당 상수를 사용하게 하기 위해서는 static final 을 같이 써야 한다.



* 자식 클래스의 객체는 부모 클래스의 객체가 될 수 있지만, 부모 클래스는 자식 클래스의 객체가 될 수 없다. 



#### 업 캐스팅

>서브 클래스에서 슈퍼 클래스로 참조형 형 변환을 하는 것
>
>-> 서브 클래스의 인스턴스를 슈퍼 클래스 타입으로 변환 하는 것
>
>```
>부모 x 자식 y
>
>x c1 = new y(); //꼴로 부모 클래스 타입으로 만드는 것 
>```
>
>
>
>* 자동 형변환이 일어난다. 참조 가능한 영역이 축소된다. (상속받은 메서드 한으로)
>
>* 서브 클래스 인스턴스의 멤버 중 공통 항목을 제외한 나머지를 포기 선언 하는 것
>
>* 하나의 슈퍼클래스 타입으로 여러 서브 클래스 인스턴스를 참조할 수 있다.
>
>  ex) 슈퍼클래스 = 서브 클래스;



#### 다운 캐스팅

> 슈퍼 클래스에서 서브 클래스로 참조형 형 변환을 하는 것
>
> * 강제 형변환 ( 명시적 형변환)이 필수
> * 참조 가능한 영역이 확대된다.
> * 대부분의 다운 캐스팅은 허용되지 않는다.
> * 이미 업캐스팅 된 래퍼런스를 다시 다운캐스팅 하는 경우에만 안전





# 다형성

> 다양한 형태의 성질을 가진다는 의미  
>
> 키보드의 ESC , ENTER는 버튼을 누르는 같은 동작방법이지만 다른 기능을 수행한다.
>
> 자바에선 하나의 메소드에 변수를 다르게 넣을때마다 다른 기능을 실행 한다.



#### overloading 과 다형성?

```
package myjava;

class O{
    public void a (int param) {
        System.out.println("숫자출력");
        System.out.println(param);
        
    }
    public void a (String param) {
        System.out.println("문자출력");
        System.out.println(param);
    }
    
}

public class ployy {
    public static void main(String[] args) {
        O o = new O();
        o.a(1);
        o.a("one");
    }
}

```

메소드 a에 매개변수를 다르게 받았을 때 그 변수에 따라서 같은 이름의 다른 메소드를 실행.

메소드 a는 두개의 본체를 갖고 있다. 두개의 본체는 하나의 이름인 a를 공유하고 있다.

->같은 이름이지만 다른 동작 방법을 갖고 있기 때문에 다형성의 한 예라고 할 수 있지만 이견이 존재.



####  overriding과 다형성

```
package myjava;

class A{}
class B extends A{}



public class poly2 {

    public static void main(String[] args) {
       
        A obj = new B(); // 부모 클래스 타입 A로 자식 클래스 B의 인스턴스를 생성

    }

}
```

#### 업 캐스팅

>서브 클래스에서 슈퍼 클래스로 참조형 형 변환을 하는 것
>
>-> 서브 클래스의 인스턴스를 슈퍼 클래스 타입으로 변환 하는 것
>
>```
>자식 y extends 부모 x
>
>x c1 = new y(); //꼴로 부모 클래스 타입으로 만드는 것 
>```
>
>* 자동 형변환이 일어난다. 참조 가능한 영역이 축소된다. 
>* 서브 클래스 인스턴스의 멤버 중 공통 항목을 제외한 나머지를 포기 선언.
>* 하나의 슈퍼클래스 타입으로 여러 서브 클래스 인스턴스를 참조할 수 있다.



상속, 오버라이딩

```
package myjava;

class polyA{
    public String x(){return "x";}
}
class polyB extends polyA{
    public String y(){return "y";}
}
public class poly3 {
    public static void main(String[] args) {
        polyA obj = new polyB();
        obj.x(); 
        //obj.y(); 부모의 클래스 형으로 만들어졌기 때문에 사용불가
    }

```

클래스 polyB는 메소드 y를 가지고 있음에도 실행이 불가하다.

즉, 클래스 polyB의 데이터 형을 클래스 polyA로 하면 클래스 polyB는 마치 클래스 polyA인 것 처럼 동작하게 된다. 사용자 입장에선 클래스 polyB를 클래스 polyA처럼 사용하면된다.



#### Overriding

```
package poly;


class A{
    public String x() {return "A.x";}
}

class B extends A{
    public String x() {return "B.x";}
    public String y() {return "y";}
}

public class poly4 {
    public static void main (String[] args) {
        A obj = new B();
        System.out.println(obj.x());
    }
}
```

클래스 A의 메소드x 가 클래스 B에서 오버라이딩 되었으므로,

obj.x()를 호출하면 오버라이딩 된 자식클래스의 x가 호출된다.

->클래스 B를 클래스A의 데이터 타입으로 인스턴스화 했을 때 클래스 A에 존재하는 맴버만이 클래스 B의 맴버가 된다.  클래스 B에서 오버라이딩 한 맴버의 동작방식은 그대로 유지

```
package poly;


class A5{
    public String x() {return "A.x";}
}

class B5 extends A5{
    public String x() {return "B.x";}
    public String y() {return "y";}
}
class B5_2 extends A5{
    public String x() {return "B2.x";} // 다른 두 클래스가 동시에 A5 상속받고 있다.
}

public class poly5 {
    public static void main (String[] args) {
        A5 obj = new B5();
        A5 obj2 = new B5_2();
        
        
        System.out.println(obj.x()); 
        System.out.println(obj2.x());
        //다른 자식 클래스를 둘다 부모 클래스 타입으로 인스턴스 화 했을 때, 
        //같은 메소드를 호출하면 각자 자식 클래스에서 오버라이딩 된 메소드로 실행
        // -> 다형성
    }
}

```

같은 메소드를 다른 자식 메소드에서 오버라이딩 해서 그 자식 메소드만의 메소드를 사용할 수 있다.

-> 다형성



### 어디다 ?

기존의 계산기 예제에서 '실행결과'라는 사실을 화면에 표시해주는 기능을 추가해주기.

```
package poly;


abstract class Cal {
    int left, right;
    public void setOprands(int left, int right) {
        this.left  = left;
        this.right = right;
    }
     public int summ() {
        return this.left+this.right;
    }
   
    public abstract void sum();
    public abstract void avg();
    
    public void run() {
        sum();
        avg();
    }
}

class Calplus extends Cal {

    public void sum(){
        System.out.println("+ sum : "+ summ());
        
    }
    public void avg(){
        System.out.println("+ avg : "+ summ()/2);
    }
}


class Calmin extends Cal {
    public void sum() {
        System.out.println("- sum : " + summ());
    }
    public void avg() {
        System.out.println("- avg : "+ summ()/2);
    }
}


public class Poly1{
    public static void execute(Cal calc) {
        System.out.println("실행결과"); // 매개변수 데이터 타입이 Cal이기 때문에 두개의 자식 클래스를 인스턴스화 한 후 이 메소드에 매개변수로 사용하고 싶다면 데이터 타입의 통일이 필요. 이때 부모 클래스의 데이터 타입으로 바꾸면 가능해짐 
        calc.run();
    }
    
    public static void main(String[] args){
        Cal CalP = new Calplus();
        CalP.setOprands(10,20);
        
        
        Cal Calm = new Calmin();
        Calm.setOprands(20,30); 
        
        execute(CalP);
        execute(Calm); 
    }
}

```

하나의 클래스 Cal이 다양한 동작 방법 Calplus, Calmin을 가지고 있다 -> 다형성



#### 인터페이스와 다형성

> 인터페이스를 구현하고 있는 클래스가 있을 때 이 클래스의 데이터 타입으로 인터페이스를 지정할 수 있다.

```
package poly;

interface I{}

class C implements I{}


public class Poly6 {

    public static void main(String[] args) {
        I obj = new C(); //c의 인스턴스를 인터페이스 I 클래스 타입으로 생성

    }

}

```

 클래스 C의 데이터 타입으로 인터페이스 I 가 될 수 있다.

다중상속이 지원되는 인터페이스의 특징과 결합해서 상속과는 다른 양상의 효과를 만들어 냄



#### 인터페이스의 다중 상속

```
package poly;

interface I2{
    public String A();
}


interface I3{
    public String B();
}

class D implements I2, I3{
    public String A() {
        return "A";
    }
    
    public String B() {
        return "B";
    }
}

public class poly7 {

    public static void main(String[] args) {
        D obj = new D();
        I2 objI2 = new D();
        I3 objI3 = new D();
        
        obj.A();
        obj.B();
        
        objI2.A();
        //objI2.B();
        
        //objI3.A();
        objI3.B();
       
        

    }

}

```

인스턴스 obji2의 데이터 타입을 i2로 한다는 것은 인스턴스를 외부에서 제어할 수 있는 조작장치를 인스턴스 i2의 맴버로 제한한다는 의미가 된다.

인스턴스 i2 와 인스턴스 i3로 인해서 하나의 클래스가 다양한 형태를 띄게 되는 것.





비유

```
package myjava;

interface Father{}
interface Mother{}
interface Programmer{
    public void coding();  
}
interface Beliver{}

class Steve implements father, programmer, beliver { 
//스티브는 아빠이면서 개발자면서 종교인
    public void coding() {
        System.out.println("fast"); 
    }
}

class Rachel implements mother, programmer{
// 레이첼은 엄마이면서 개발자
    public void coding() {
        System.out.println("elegance");
    }
}

public class workspace{
    public static void main(String[] args) {
        programmer employee1 = new Steve();
        programmer employee2 = new Rachel();
        
        employee1.coding();
        employee2.coding();
    }


}
```



-----------------------------------------------



# 예외 란?

> 프로그래밍 하면 많은 오류를 직면하게 된다. 이런 오류 들을 잘 처리하기 위한 방법 중 하나.
>
> 예외란 프로그램을 만든 프로그래머가 상정한 정상적인 처리에서 벗어나는 경우에 이를 처리하기 위한 방법. 예기치 못한 오류를 어떻게 처리하는가.

```java
class Calculator{
    int left, right;
    public void setOprands(int left, int right){
        this.left = left;
        this.right = right;
    }
    public void divide(){
        System.out.print("계산결과는 ");
        System.out.print(this.left/this.right); // 오류가 난다. 
        
        System.out.print(" 입니다.");
    }
} 
public class CalculatorDemo {
    public static void main(String[] args) {
        Calculator c1 = new Calculator();
        c1.setOprands(10, 0);
        c1.divide();
    }
}
```

> 계산 결과는  후 부터 오류가 난다. 이는 11행에서 오류가 발생했다는 것. 
>
> 이유는 10을 0으로 나누려고 했기 때문





에러메세지는 시스템에 어떤 오류가 발생했을 때 그 오류를 이해하고 파악하는데 큰 도움이 된다.

이 문제를 어떻게 해결해야 할까.



try catch0

```java
package javajava;

class Calculator {
    int left, right;
    public void setOprands(int left, int right) {
        this.left = left;
        this.right = right;
    }
    
    public void divide() {
        try {
            System.out.print("계산결과는");
            System.out.print(this.left/this.right);
            System.out.println("입니다.");
        }catch(Exception e) {
            System.out.println("오류가 발생했습니다 :"+e.getMessage());
        }
    }
//e는 변수. 이 변수의 데이터 타입은 Exception. 이는 자바에서 기본적으로 제공하는 클래스로 java.lang 에 소속되어 있다. 예외가 발생하면 자바는 마치 메소드를 호출하듯이 catch를 호출하면서 그 인자로 Exception 클래스의 인스턴스를 전달하는 것이다.
//이때 e.getMessage() 는 자바가 인스턴스의 메소드 중 getMessage를 호출하는 코드. 
//getMessage는 오류의 원인을 사람이 이해하기 쉬운 형태로 리턴하도록 약속되어 있다.
}

public class CalculatorDemo{
    
    public static void main(String[] args) {
       
        Calculator c1 = new Calculator();
        c1.setOprands(10,0);
        c1.divide();
        
        Calculator c2 = new Calculator();
        c2.setOprands(10,5);
        c2.divide();
    }
}

```

```
계산결과는
오류가 발생했습니다 :/ by zero 
계산결과는
2
입니다.

```

12행까지는 실행되었지만 13행은 실행되지 않았다.

오류가 발생하지 않았다. 정상적인 애플리케이션인 것처럼 동작. try...catch 문 때문 



#### try... catch 문

```
try {
	예외의 발생이 예상되는 로직
}
catch(예외클래스 인스턴스){
	예외가 발생했을 때 실행되는 로직
}
```

```
}catch(Exception e) {
            System.out.println("오류가 발생했습니다 :"+e.getMessage());
        }
```

e는 변수. 이 변수의 데이터 타입은 Exception. 이는 자바에서 기본적으로 제공하는 클래스로 java.lang 에 소속되어 있다. 예외가 발생하면 자바는 마치 메소드를 호출하듯이 catch를 호출하면서 그 인자로 Exception 클래스의 인스턴스를 전달하는 것이다.

이때 e.getMessage() 는 자바가 인스턴스의 메소드 중 getMessage를 호출하는 코드. 

getMessage는 오류의 원인을 사람이 이해하기 쉬운 형태로 리턴하도록 약속되어 있다. 



#### 뒷 수습의 방법

```java
package javajava;

class Calculator22 {
    int left, right;
    public void setOprands(int left, int right) {
        this.left = left;
        this.right = right;
    }
    
    public void divide() {
        try {
            System.out.print("계산결과는");
            System.out.print(this.left/this.right);
            System.out.println("입니다.");
        }catch(Exception e) {
            System.out.println("\n\n e.getMessage()\n"+e.getMessage());
            System.out.println("\n\n e.toString()\n"+e.toString());
            System.out.println("\n\n e.printStackTrace()");
            e.printStackTrace();

        }
    }
    
}

public class CalculatorDemo2{
    
    public static void main(String[] args) {
       
        Calculator22 c1 = new Calculator22();
        c1.setOprands(10,0);
        c1.divide();
        
       
    }
}

```

스택 : 후입선출 콜스택 스택트레이스 .. 호출된 순서를 저장. 

자바에서 기본적으로 제공하는 뒷수습의 방법들

```
계산결과는

 e.getMessage()
/ by zero


 e.toString()
java.lang.ArithmeticException: / by zero


 e.printStackTrace()
java.lang.ArithmeticException: / by zero
	at javajava.Calculator22.divide(CalculatorDemo2.java:13)
	at javajava.CalculatorDemo2.main(CalculatorDemo2.java:32)

```

* e.getMessage() : 오류에 대한 기본적인 내용을 리턴. 상세하진 않다.

* e.toString() : 좀 더 자세한 예외정보를 제공한다. 

  * java.lang.ArithmeticException 는 발생한 예외가 어떤 예외에 해당하는지에 대한 정보

  * ArithmeticException 는 수학적인 계산 과정에서 발생하는 예외상황을 의미.

    

* e.printStackTrace() : 위 두개의 메소드와는 다르게 리턴값이 없다.  메소드를 호출하기만 하면 내부적으로 예외 결과를 화면에 출력해줌. 가장 자세한 정보를 제공



오류의 예시

ArrayIndexOutOfBoundsException

```java
package javajava;

class A{
    private int[] arr = new int[3];
    A() {
        arr[0]=0;
        arr[1]=10;
        arr[2]=20;
    }
    public void z(int first, int second) {
        System.out.println(arr[first]/arr[second]);
        
    }

}

public class CalculatorDemo3{
    
    public static void main(String[] args) {
       
        A a = new A();
        a.z(10,1); // 10,1 인자를 넣으면 arr[10]/arr[1]이 된다. 이 배열은 크기가 3인 배열이므로 인덱스 범위를 초과하여 존재하지 않는 인덱스를 호출하고 있다.
    }
}
```

오류

```
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 10
//배열이 갖을 수 있는 인덱스의 범위를 벗어났다.
	at javajava.A.z(CalculatorDemo3.java:11)
	//11번째 줄에서 오류가 생겨났다.
	at javajava.CalculatorDemo3.main(CalculatorDemo3.java:22)

```



/ by zero

```java
package javajava;

class A{
    private int[] arr = new int[3];
    A() {
        arr[0]=0;
        arr[1]=10;
        arr[2]=20;
    }
    public void z(int first, int second) {
        System.out.println(arr[first]/arr[second]);
        
    }

}

public class CalculatorDemo3{
    
    public static void main(String[] args) {
       
        A a = new A();
        a.z(1,0); // 1,0 인자를 넣으면 arr[1]/arr[0]이 된다. 1/0이므로 오류.
    }
}
```

오류

```
Exception in thread "main" java.lang.ArithmeticException: / by zero
	at javajava.A.z(CalculatorDemo3.java:11)
	at javajava.CalculatorDemo3.main(CalculatorDemo3.java:22)

```



다양한 오류를 한번에 예외 처리 해주기

#### 오류의 종류에 따라 다르게 출력해 줄 수 도 있다.

```java
package javajava;

class A4{
    private int[] arr = new int[3];
    A4() {
        arr[0]=0;
        arr[1]=10;
        arr[2]=20;
    }
    public void z(int first, int second) {
        try {
            System.out.println(arr[first]/arr[second]);
        }catch(ArrayIndexOutOfBoundsException e) {
                System.out.println("ArrayIndexOutOfBoundsException");
        }catch(ArithmeticException e) {
                System.out.println("ArithmeticException");
        }catch(Exception e) {
            System.out.println("Exception");

        } //여러개의 catch를 하나의 try 구문에서 사용할 수 있다. 이를 통해 보다 간편하게
        //다양한 상황에 대응할 수 있다.
    }

}

public class CalculatorDemo4{
    
    public static void main(String[] args) {
       
        A4 a1 = new A4();
        a1.z(10,0);
        a1.z(1,0);
        a1.z(2,1);

    }
}

```

```
ArrayIndexOutOfBoundsException
ArithmeticException
2
```



여러개의 catch를 사용할 때 고려해야할 사항

```java
    public void z(int first, int second) {
        try {
            System.out.println(arr[first]/arr[second]);
        }catch(Exception e) {
                System.out.println("Exception");            
   
        }catch(ArrayIndexOutOfBoundsException e) {
                System.out.println("ArrayIndexOutOfBoundsException");
        }catch(ArithmeticException e) {
                System.out.println("ArithmeticException");


        } 
```

Exception이 ArrayIndexOutBoundsException, ArithemeticException 보다 포괄적인 예외를 의미하기 때문에 Exception 이후에 등장하는 catch 문은 실행될 수 없는 구문이기 때문에 오류.

자바 컴파일러가 불필요한 로직을 감지하고 이를 개발자에게 알려주는 것.

runtimeException안에 대부분 포함



#### finally

> try 구문에서 예외가 발생하는 것과 상관없이 언제나 실행되는 로직.

```java
package javajava;

class A4{
    private int[] arr = new int[3];
    A4() {
        arr[0]=0;
        arr[1]=10;
        arr[2]=20; // 생성자
    }
    public void z(int first, int second) {
        try {
            System.out.println(arr[first]/arr[second]);
        }catch(ArrayIndexOutOfBoundsException e) {
                System.out.println("ArrayIndexOutOfBoundsException");
        }catch(ArithmeticException e) {
                System.out.println("ArithmeticException");
        }catch(Exception e) {
            System.out.println("Exception");
        }finally {
            System.out.println("finally");

        }
    }

}

public class CalculatorDemo5{
    
    public static void main(String[] args) {
       
        A4 a1 = new A4();
        a1.z(10,0);
        a1.z(1,0);
        a1.z(2,1);

    }
}

```

```
ArrayIndexOutOfBoundsException
finally
ArithmeticException
finally
2
finally
```

예외와 상관없이 각각의  trycatch 문이 끝나고 finally 라는 문자 출력

> 언제 사용할까?
>
> ex) 데이터 베이스 서버에 접속해야하는 경우. 예외가 발생하던 안하던 후속 작업을 수행해야 하는데. 데이터 베이스 접속을 끊지 않으면 데이터 베이스 연결상태를 유지하게 되고 급기야 더이상 접속을 수용할 수 없는 상태가 될 수 도 있기 때문에. 
>
> 접속을 끊는 작업은 예외 발생여부와 상관없이 필수적인 처리이기 때문에 finally를 사용한다.

-> 실행결과에 상관없이 항상 수행해야하는 작업.  예기치 못한 상황이 생기면 뒷정리를 해주는 작업



# 예외 던지기

설계자의 의도에 따라서 예외를 반드시 처리해야 하는 경우가 있다.



파일의 내용을 출력하기.

```java
import java.io.*;
public class CheckedExceptionDemo {
    public static void main(String[] args) {
        BufferedReader bReader = new BufferedReader(new FileReader("out.txt"));//new 로 시작하면 생성자를 호출하는 것.
        //FileReader객체의 인자값으로 파일 명을 받아 그 인스턴스를 객체의 생성자에게 전달 해서 새로운 객체를 만들어서 BufferedReader데이터 타입의 bReader라는 변수에 넣음
        String input = bReader.readLine(); //BufferedReader클래스의 readline메소드 호출/ 파일 내용을 인풋에 담음
        System.out.println(input); 
    }
}
```

오류

```
Exception in thread "main" java.lang.Error: Unresolved compilation problems: 
	Unhandled exception type FileNotFoundException
	Unhandled exception type IOException

	at javajava.CheckedExceptionDemo.main(CheckedExceptionDemo.java:6)
```



```
Unhandled exception type FileNotFoundException
```

: new` `FileReader(``"out.txt"``)에 대한 예외 처리가 필요하다. 라는 뜻



#### 해결

> 꼭 예외처리를 해주어야 하는 것 들이 있음. 이건 f1을 눌러서 throws에서 확인 가능

FileReader는  throws 에는 FileNotFoundException 이 있다. 이 오류에 대한 예외 처리를 필수로 해야한다.

* FileNotFoundException : 이름에 해당하는 파일이 존재하지 않으면 문제가 생긴다. 그 때 파일 낫 파운드라는 익셉션이 발생한다. 파일리더 생성자를 사용하는 쪽에서 반드시 파일낫파운드에 대한 예외처리를 해야한다. 

BufferedReader 클래스의 readLine 메소드는 IOException를 예외처리 해주어야 한다.

```java
package javajava;
import java.io.*;
public class CheckedExceptionDemo {
    public static void main(String[] args) {
        BufferedReader bReader = null; //초기화
        try {
           BufferedReader bReader = new BufferedReader(new FileReader("out.txt"));
        } catch (FileNotFoundException e) {		//예외처리

            e.printStackTrace();
        }
        
        String input = null; //초기화
        try {
            input = bReader.readLine();
        } catch (IOException e) {				//예외처리

            e.printStackTrace();
        } 
        System.out.println(input); 
    }
}
```





# throw와 throws

우리도 예외를 던질 수 있다.



```java
package javajava;
import java.io.*;

class B{
    void run(){
    }
}
class C{
    void run(){
        B b = new B();
        b.run();
    }
}
public class ThrowExceptionDemo {
    public static void main(String[] args) {
         C c = new C();
         c.run();
    }   
}
```



try... catch...finally 

#### B에서 예외 발생 

#### -> B에서 C에게 던질 수 있다. 

#### -> C가 ThrowExceptionDemo에 넘길 수 있다. 

#### ->일반 사용자에게 넘길 수 있다.





```java
package javajava;
import java.io.*;
class B{
    void run(){
        BufferedReader bReader = null;
        String input = null;
        try {
            bReader = new BufferedReader(new FileReader("out.txt"));
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
        try{
            input = bReader.readLine();
        } catch (IOException e){
            e.printStackTrace();
        }       
        System.out.println(input); 
    }
}
class C{
    void run(){
        B b = new B();
        b.run();
    }
}
public class ThrowExceptionDemo {
    public static void main(String[] args) {
         C c = new C();
         c.run();
    }   
}
```



#### B->C 로 던지기

> 넘길 코드가 들어있는 메소드 명 뒤에 throws 오류명을 쓰고 해당 트라이 캐치 문을 지우고 
>
> 넘겨주는 클래스의 메소드안에 트라이 캐치 문을 넣는다.

```java
package javajava;
import java.io.*;
class B{  //최초 사용자
    void run() throws FileNotFoundException, IOException{ 
        BufferedReader bReader = null;
        String input = null;
        bReader = new BufferedReader(new FileReader("out.txt"));
        input = bReader.readLine();
        System.out.println(input); 
    }
}
class C{
    void run(){ //b의 run을 사용하고 있다. 
        B b = new B();
        try {
                b.run();
        } catch (FileNotFoundException e) {
                e.printStackTrace();
        } catch (IOException e) {
                e.printStackTrace();
        } //여기서 예외를 처리하게 넘길 수 있다. 
    }
}
public class ThrowExceptionDemo { //최종 사용자
    public static void main(String[] args) {
         C c = new C();
         c.run();
    }   
}
```

B 내부의 try...catch 구문은 제거되었고 run 옆에 throws IOException, FileNotFoundException이 추가되었다. 

이것은 B.run 내부에서 IOException, FileNotFoundException에 해당하는 예외가 발생하면 

이에 대한 처리를 B.run의 사용자 C에게 위임하는 것이다. 



#### C->ThrowExceptionDemo 로 던지기

```java
package javajava;

import java.io.*;
class B{  //최초 사용자
    void run() throws FileNotFoundException, IOException{ 
        BufferedReader bReader = null;
        String input = null;
        bReader = new BufferedReader(new FileReader("outt.txt"));
        input = bReader.readLine();
        System.out.println(input); 
    }
}
class C{
    void run() throws FileNotFoundException, IOException{ //b의 run을 사용하고 있다. 
        B b = new B();
        b.run();

    }
}
public class ThrowExceptionDemo { //최종 사용자
    public static void main(String[] args) {
         
         C c = new C();
         
         try {
            c.run();
        } catch (FileNotFoundException e) {
            System.out.println("out.txt 파일은 설정 파일 입니다. 이 파일이 프로젝트 루트 디렉토리에 존재해야 합니다.");
            e.printStackTrace();
        } catch (IOException e) {
            
            e.printStackTrace();
        }
    }   
}
```



out.txt파일을 찾을 수 없는 상황은 B.run 입장에서는 어떻게 할 수 있는 일이 아니다. 엔드 유저인 어플리케이션의 사용자가 out.txt파일을 루트 디렉토리에 위치시켜야 하는 문제이기 때문에 에플리캐이션의 진입점읜 메소드 main 으로 책임을 넘겼다.



#### 소비자에서 생산자로

> API의 소비자로서 API 측에서 던지는 예외를 처리하는 방법을 알아봤다. 
>
> 이제는 그 예외를 직접 API 생산자의 입장에서 생각해보자.



원래는 자바가 대신 처리

```java
class Calculator{
    int left, right;
    public void setOprands(int left, int right){
        this.left = left;
        this.right = right;
    }
    public void divide(){
        try {
            System.out.print("계산결과는 ");
            System.out.print(this.left/this.right); try문 안의 코드 실행중 오류가 나면 정지 후 캐치,
            System.out.print(" 입니다.");
        } catch(Exception e){
            System.out.println("\n\ne.getMessage()\n"+e.getMessage());
            System.out.println("\n\ne.toString()\n"+e.toString());
            System.out.println("\n\ne.printStackTrace()");
            e.printStackTrace();
        }
    }
} 
public class CalculatorDemo {
    public static void main(String[] args) {
        Calculator c1 = new Calculator();
        c1.setOprands(10, 0);
      
        c1.divide();
      
    }
}


```

c1인스턴스의 메소드로 10,0을 주어 두개의 변수에 들어가 10/0을 해야해서 수학적 오류 발생 .

-> 통제하고 있는 상황은 아님. 자바 가 우리 대신 오류가 남을 인지하고 오류메세지를 출력해 주는 것





##### 우리가 통제 해서 예외처리를 할 수 있는 방법? 2가지 (오류의 조건을 직접 정의해주기)

1. setpornads 의 두번째인자로 0이 들어오게 되면 부적합하다고 막을 수 있다.

조건문을 통해서 라이트로 들어오는 값을 감시해서 그 값이 0이라고 한다면 

익셉션이 발생하도록 하면 된다. -> illegalargumentexception



2. 디바이드를 실행 할 때, 메소드 시작 점에서 체크를 하는 것.

라이트의 값이 0이라면 익셉션을 발생시키는 것

-> arithmethicexception 



1. IllegalArgumentException

```java
package javajava;

class Calculator23 {
    int left, right;
    public void setOprands(int left, int right) {
        if(right ==0) {
            throw new IllegalArgumentException("두번째 인자의 값은 0이 될 수 없다");}// 예외 클래스를 생성하여 생성자에 이 문자열을 넣음. 
        this.left = left;
        this.right = right;

        }
    
    
    public void divide1() {
         
        try {
            System.out.print("계산결과는");
            System.out.print(this.left/this.right);
            System.out.println("입니다.");
        }catch(Exception e) {
            System.out.println("\n\n e.getMessage()\n"+e.getMessage());
            System.out.println("\n\n e.toString()\n"+e.toString());
            System.out.println("\n\n e.printStackTrace()");
            e.printStackTrace();

        }
    }
    
}
public class CalculatorDemo{
    
    public static void main(String[] args) {
       
        Calculator23 c1 = new Calculator23();
        c1.setOprands(10,0);
        c1.divide1();

    }
}


```

두번째 인자 값이 0 일 때 setOprands의 사용자에게 예외 클래스인 illegalArgumentException을 던지고 있다. 사용자인 main은 예외와 함께 두번째 인자값은 0이 될수 없습니다. 라는 메세지를 받게 되고 이를 바탕으로 전달값을 변경하게 된다. 

-> 전역으로 두번째 인자에 0이 들어오지 못하게 됨 



2.

```java
package javajava;

class Calculatorw {
    int left, right;
    public void setOprands(int left, int right) {
       
        this.left = left;
        this.right = right;

        }
    
    
    public void divide1() {
             if(right ==0) {
            throw new ArithmeticException("0으로 나눌 수 없습니다.");}// 이 인셉션 클래스의 인자로 문자열을 넣어줌. 
        try {
            System.out.print("계산결과는");
            System.out.print(this.left/this.right);
            System.out.println("입니다.");
        }catch(Exception e) {
            System.out.println("\n\n e.getMessage()\n"+e.getMessage());
            System.out.println("\n\n e.toString()\n"+e.toString());
            System.out.println("\n\n e.printStackTrace()");
            e.printStackTrace();

        }
    }
    
}

public class sfedf {
    public static void main(String[] args) {
        Calculatorw c1 = new Calculatorw();
        c1.setOprands(10, 0);
        try{
            c1.divide1();
        }catch(ArithmeticException e){
            System.out.println(e.getMessage());
        }
    }
}

```

-> 해당 메소드 안에서만 지역변수로 들어오지 못하게 됨

> 2번째 방법이 더 적절. sum avg 는 계산 할 수 있기 때문,





throw 는 예외를 발생시키는 명령, throw뒤에는 예외 정보를 가지고 있는 예외 클래스가 위치.

자바 가상머신은 이 클래스를 기준으로 catch 구문을 실행할 것인지 결정.



* 자바가 정해놓은 예외 우리가 사용하도록 권장한 것들

| 예외                      | 사용해야 할 상황                            |
| ------------------------- | ------------------------------------------- |
| IllegalArgumentException  | 매개변수가 의도하지 않은 상황을 유발시킬 때 |
| IllegalStateException     | 메소드를 호출하기 위한 상태가 아닐 때       |
| NullPointerException      | 매개 변수 값이 null 일 때                   |
| IndexOutOfBoundsException | 인덱스 매개 변수 값이 범위를 벗어날 때      |
| ArithmeticException       | 산술적인 연산에 오류가 있을 때              |

-----------------------------------------



#### 예외의 여러가지 상황들, 반드시 처리하도록 강제/ 사용자의 선택

1.ArithmeticException

```
package javajava;

public class Exception1 {
    void throwArithmeticException() {
        throw new ArithmeticException();

    }

}
```

이미 이클립스에 있는 ArithmeticException()를 만들었다.

문제 없이 컴파일 됨



2.IOException

```
package javajava;

public class Exception1 {
    void throwArithmeticException() {
        throw new ArithmeticException();
       

    }
    void throwIOException() {
        throw new IOException();
    }
	public static void main(String[] args) {
   
    }
}

}

```

> IOException()에 오류 표시가 난다.
>
> ```
> Unhandled exception type IOException
> ```



해결하기

1. try catch 로 예외처리

```
import java.io.IOException;
class E{
    void throwArithmeticException(){
        throw new ArithmeticException();
    }
    void throwIOException(){
        try{
        throw new IOException();
        }catch(IOException e){
        	e.printStackTrace();
        }
    }
}
```



2. throws로 사용자에게 넘겨주기

```
package javajava;

import java.io.IOException;

public class Exception1 {
    void throwArithmeticException() {
        throw new ArithmeticException();
    }
    void throw IOException() throws IOException {
        throw new IOException();
    }
    public static void main(String[] args) {
   
    }
}


```

왜 IOException는 예외처리를 해줘야 하는가?

>  IOException()는 try catch 하거나 throw 해야 한다는 것이다. 왜 IOException() 에만?



#### Throwable -예외의 선조

-------------------------

ArithmeticException 은 Exception 의 하위 클래스 

Exception 클래스가 더 많은 예외 상황을 포괄하는 것. ArithmeticException 클래스는 더 구체적인 상황을 특정하는 것.





![img](https://blogfiles.pstatic.net/MjAxOTAzMjdfNzkg/MDAxNTUzNjE5MTAwNDAw.jXOP-IelUtsDOs2Va0RAmXATFctJpI6-Xsz4VBo8vB0g.wM53gFDvMxkPcI3R6-KvKxov_mYeLhXiSmzvaztJ8ukg.PNG.mdown/%EC%98%88%EC%99%B8%ED%8F%AC%ED%95%A8%EA%B4%80%EA%B3%843.png?type=w1)





Throwable : 범 예외 클래스 들의 공통된 조상. 모든 예외 클래스 들이 가지고 있는 공통 메소드를 정의하고 있다. 하지만 직접 사용하진 않음



Error : 애플리케이션의 문제가 아니라 그 애플리케이션이 동작하는 가상 머신에 문제가 생겼을 때 발생하는 예외. 

- 트라이 캐치 안해도 됨, 메모리가 너무 많이 사용된 경우, 너무 적은 메모리를 지원하는 경우

- 효율적으로 사용, 한계치를 조정



Exception :

- checked 예외 - RuntimeException을 제외한 Exception의 하위 클래스

  반드시 예외처리를 해야하는 것 try catch

- unchekced 예외 - RuntimeException의 하위 클래스

  해도되고 안해도 되는 것





#### 언제 사용하는지?

체크드 :

 예외상황에서 복구할 수 있는 여지가 있을 때는 체크드 를 사용하는게 맞다

filenotFound, 파일을 찾을 수 없는 건 복구 가능하다. 



언체크드 : 

사용자가 할 수 있는 것이 없다. 종료시키는 것이 최선일때

Arithmethic(런타임의 하위 클래스)

사용자가 api 사용법이 있을 때, 

 

### 나만의 예외 만들기

-----------------------------------------

> 기본적으로 제공하는 예외 표준 예외 클래스를 사용하는 것이 좋다.
>
> 자바 개발자들에게 익숙하다. 불필요하게 클래스를 선언하게 되면 자원을 더 많이 사용하게 된다.
>
> 하지만 ,
>
> 상황에 따라 사용자가 원하는 로직상의 예외처리를 해주기 위해 사용,



가장먼저 해야할 것 : 체크드 or 언체크드? 예외처리를 강제할 것인지

### RuntimeException 를 상속 받는 나만의 예외 만들기.

#### 예외처리를 강제하지 않는 예외 만들기

---------------------

원래 있던 코드에서는 기존에 있던  ArithmeticException을 사용했다.

하지만 내가 특정 경우의 예외를 DivideException로 만들어 주고 싶다. 

```java
package org.opentutorials.javatutorials.exception;
class DivideException extends RuntimeException {
    DivideException(){
        super();
    }
    DivideException(String message){
        super(message);
    }
}
class Calculator{
    int left, right;
    public void setOprands(int left, int right){        
        this.left = left;
        this.right = right;
    }
    public void divide(){
        if(this.right == 0){
            throw new DivideException("0으로 나누는 것은 허용되지 않습니다.");
        }
        System.out.print(this.left/this.right);
    }
}
public class CalculatorDemo {
    public static void main(String[] args) {
        Calculator c1 = new Calculator();
        c1.setOprands(10, 0);
        c1.divide();
    }
}
```





Exception의 하위 클래스로 바꾼다면?

-> 체크드 인셉션 : 예외처리를 해야한다.

```
package javajava;

class DivideException extends Exception{
    DivideException(){
        super();
    }
    
    DivideException(String message){
        super(message);
        
    }
}
class Calculatorq{
    int left, right;
    public void setOprands(int left, int right) {
        this.left = left;
        this.right = right;
    }
    public void divide() {
        if(this.right==0) {
            throw new DivideException("0으로 나누는 것은 허용되지 않습니다.");
  ㅅ      } //여기서 오류,
        System.out.print(this.left/this.right);
        
    }
}

public class Exception2 {
    public static void main(String[] args) {
        Calculatorq c1 = new Calculatorq();
        c1.setOprands(10, 0);
        c1.divide();
    }
}



```



->2가지 방법



1. try catch로 예외 처리 하기 

```java
package javajava;

class DivideException2 extends Exception{
    DivideException2(){
        super();
    }
    
    DivideException2(String message){
        super(message);
        
    }
}
class Calculatorq{
    int left, right;
    public void setOprands(int left, int right) {
        this.left = left;
        this.right = right;
    }
    public void divide() {
        if(this.right==0) {
            try {
                throw new DivideException2("0으로 나누는 것은 허용되지 않습니다.");
        } catch(DivideException2 e) {
            e.printStackTrace();
        }
        }
        System.out.print(this.left/this.right);
        
    }
}

public class Exception2 {
    public static void main(String[] args) {
        Calculatorq c1 = new Calculatorq();
        c1.setOprands(10, 0);
        c1.divide();
    }
}


```

2. 사용자에게 예외를 던지기. 사용자는 반드시 예외에 대한 처리를 해야함

```java
package javajava;

class DivideException2 extends Exception{
    DivideException2(){
        super();
    }
    
    DivideException2(String message){
        super(message);
        
    }
}
class Calculatorq{
    int left, right;
    public void setOprands(int left, int right) {
        this.left = left;
        this.right = right;
    }
    public void divide() throws DivideException2{
        if(this.right==0) {
            try {
                throw new DivideException2("0으로 나누는 것은 허용되지 않습니다.");
        } catch(DivideException2 e) {
            e.printStackTrace();
        }
        }
        System.out.print(this.left/this.right);
        
    }
}

public class Exception2 {
    public static void main(String[] args) {
        Calculatorq c1 = new Calculatorq();
        c1.setOprands(10, 0);
        try {
            c1.divide();
        } catch (DivideException2 e) {
            e.printStackTrace();
        }
    }
}



```



throw new ArithmeticException ("생성자");

예외가 발생 . 실행 종료,



throw 뒤에 어떤 객체가 있는지에 따라서 이 객체를 갖고 있다가 



변수 안에는 우리가 입력한 메세지 값이 들어 있다. .

아리스 메틱 이라는 객체 안에 메세지값을 넣을 수 있다. 



트라이 문안에 예외 처리 해야하는 부분을 넣을 수 있다.



api를 만들고 예외상황을 만들어서 넘기는 방법



반드시 처리하도록 강제하기



------------------------------------------

# 상수

enum : 자바 5.0부터 제공된 것

다른 방식으로 사용해왔다.



상수 : 변하지 않는 값

```
int x=1; //좌항이 변수 우항이 상수
```

```
1=2; 1은 고정된 값. 1에 2를 넣을 수 없음
```



```java
Public class ConstantDemo{
	public static void main(String[] args) {
	
	//1 = 사과, 2 = 복숭아, 3=바나나
	int type = 1;
	swich(type){
        case 1:
            System.out.println(57);
            break;
        case 2:
            System.out.println(34);
            break;		
        case 3:
            System.out.println(93);
            break;
   		 }
   	}
}   	
```

> 1에 해당하는 과일은 언제나 사과여야한다. 이러한 사실은 주석에 쓰여있다.
>
> 하지만 주석이 없어졌거나, 주석이 코드와 멀어진다면 각 숫자가 해당하는 과일이 무엇인가를 알아보기 어렵다.



이런 때는 이름이 있다면 더 좋을 것이다. 변수도 상수가 될 수 있다.

#### 변수를 지정하고 그 변수를 final로 처리하면 된다.

```
package javajava;

public class ConstantDemo {
    private final static int APPLE =1 ;
    private final static int PEACH =2 ;
    private final static int BANANA =3 ;
    public static void main(String[] args) {
        int type = APPLE;
        switch(type) {
            case APPLE:
                System.out.println(57+"kcal");
                break;
            case PEACH:
                System.out.println(34+"kcal");
                break;
            case BANANA:
                System.out.println(93+"kcal");
                break;
        }
    }
}

```



이경우에는 문제가 없다. 하지만 프로그램이 커지면서 기업에 대한 상수가 필요해졌다

과일 : APPLE, PEACH, BANAN / 회사 : GOOGLE, APPLE, ORACLE



```
package javajava;

public class ConstantDemo {
    private final static int APPLE =1 ;
    private final static int PEACH =2 ;
    private final static int BANANA =3 ;
    
    private final static int GOOGLE =1 ;
    private final static int APPLE =2 ;
    //과일 APPLE 과 기업 APPLE이 서로 같은 이름을 갖은다. 이렇게 되면 APPLE값이 2에서 1로 바뀐다. 프로그램은 오동작 할것이다. 하지만 FINAL로 선언 했기 때문에 컴파일이 되지 않고 이름이 중복되는 문제는 막을 순 있다.
    private final static int ORCLE =3 ;
    
    
    public static void main(String[] args) {
        int type = APPLE;
        switch(type) {
            case APPLE:
                System.out.println(57+"kcal");
                break;
            case PEACH:
                System.out.println(34+"kcal");
                break;
            case BANANA:
                System.out.println(93+"kcal");
                break;
        }
    }
}


```



-> 접두사를 붙혀보기

```
package javajava;

public class ConstantDemo {
    private final static int FRUIT_APPLE =1 ;
    private final static int FRUIT_PEACH =2 ;
    private final static int FRUIT_BANANA =3 ;
    
    private final static int COMPANY_GOOGLE =1 ;
    private final static int COMPANY_APPLE =2 ;
    private final static int COMPANY_ORCLE =3 ; //네임 스페이스
    
    
    public static void main(String[] args) {
        int type = FRUIT_APPLE;
        switch(type) {
            case FRUIT_APPLE:
                System.out.println(57+"kcal");
                break;
            case FRUIT_PEACH:
                System.out.println(34+"kcal");
                break;
            case FRUIT_BANANA:
                System.out.println(93+"kcal");
                break;
        }
    }
}

```

중복의 문제는 해결, 하지만 상수가 너무 지저분



-> 인터페이스를 사용



```
package javajava;

interface FRUIT{
    int APPLE =1, PEACH=2, BANANA=3;
}

interface COMPANY{
    int GOOGLE=1, APPLE=2, ORACLE=3;
}

public class ConstantDemo {

    
    public static void main(String[] args) {
        int type = FRUIT.APPLE;
        switch(type) {
            case FRUIT.APPLE:
                System.out.println(57+"kcal");
                break;
            case FRUIT.PEACH:
                System.out.println(34+"kcal");
                break;
            case FRUIT.BANANA:
                System.out.println(93+"kcal");
                break;
        }
    }
}

```





private final ststic int APPLE =1;

private final ststic int PEACH =2;

private final ststic int BANANA =3;

public static void main (String[] args){

​	int type = APPLE;

​	switch()}



이넘 열거형 enumerated type 열거형은 서로 연관된 상수들의 집합

패턴들을 자바에서 수용한 것. 사람들끼리 약속한 것.

```
enum Fruit{// 클래스. 간략한 코드로 구현했다는 것을 알려주기 위해 enum 붙힘
	APPLE, PEACH, BANANA
}
```





















