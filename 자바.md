## 200721

# 변수



자바는 다른 언어에 비해 자료형 선언 같은 것들이 엄격하다. 컴파일 단계에서 예상되는 문제점을 예측할 수 있다.  금융이나 과학적 계산처럼 엄격함이 요구되는 분야에 주로 사용

\를 " 앞에 위치시키면 단순히 문자로 해석하도록 할 수 있다.

실수형 변수 : double  8byte / float 4byte  부동소수점 근삿값으로 소수를 표현    mbyte  : 2^(m*8) 개의 숫자 가능 0중심

 ```
float a = 2.0F 
float a = (float)100.0
//정수가 아닌 실수값은 그 자체로 double 값이다. 그러므로 float에 저장하기 위해선 형변환을 해야한다.
long a = 2147483648L //int에 저장될 수 있는 최댓값을 넘었기 때문에
 ```

```
byte a = 100;
short b = 200; //이건 가능 int 허용하기 때문   
```



byte -> short char -> int -> long -> float -> double

자동형 변환은 작은 범위에서 넓은 데이터 타입으로의 변환만 허용이고 형변환을 따로 안해줘도 저절로 상수 값이 변환되어 변수에 저장되는 것이다.

명시적 형변환은 (데이터타입)데이터 값 형태로 직접 써서 변환 시켜주는 것이다. 이는 넓은 데이터에서 좁은 데이터로 바꾸는 데 쓰임 이는 데이터 손실이 일어나므로 버그를 없애기위해 사용



문자형 변수 : char 2byte

문자열 : string 글자들의 집합  2*글자수 byte

모든 객체는 힙 메모리에 위치한다. 힙메모리는 프로세스가 실행될 때 운영체계로 부터 할당, 자바는 자바 가상머신이 실행될 때 운영체계로 부터 힙메모리를 할당받는다. 힙메모리는 고정되어 있을 수도 가변적일 수도 있다. 초기힙, 최대 힙 메모리의 양을 설정할 수도 있다. 최대는 2GB! 따라서 string 클래스의 문자열의 최대 가능 길읻 2GB가 한계

```
java-Xms16s Xms128m Myclass
(초기값 16, 최대 힙 메모리 128)
```



-> string 클래스의 문자열 길이의 한계는 하드웨어 머신과 운영체계에서 허용하는 최대한의 크기까지 가능. 특별히 규약에서 제약하는 사항은 없다. 자바 가상 머신에 따라 힙 메모리 할당에 옵션 설정이 있을 수 있다.

 변수 두개 동시 선언 가능

alert?



# 연산자



정수 * 정수 - 정수

정수*실수 - 실수 로 형변환



boolean 참 거짓을 의미하는 데이터 타입

.equals 는 문자열을 비교할 때 사용하는 메소드 a.equals(b)



# 조건문

if

```
if(true){
then 절
}
```

```
if(){
}else{
}
```

```
if(){
}else if(){
}else{
}
```

스위치

```
switch(입력값){
case 1 :
case 2 :
case 3 :
...
default: //입력값이 주어진 케이스에 없으면 실행
}
```

각 케이스마다 break가 없으면 처음 실행된 case 부터 아래로 쭉쭉 다 실행

break 가 있으면 해당 케이스만 하고 즉시 중지



# 논리 연산자

&&  : 좌 우가 모두 참일 때 참 and

|| :  좌우 중 하나라도 참일 때 참 or

! : 부정    ^



# 반복문

```
while(i<10){
i++
}
```

조건에 true를 넣어버리면 무한반복 

```
for(초기화; 종료조건; 반복실행){
}
```

초기값을 0으로 , 원하는 반복횟수m를 i<m 로 



for(int i=1; i<=5; i++){

 m+= i*2

}



for (int i=0, i<=10, i+=2){

m+=i

}

# 배열

```
string[] classgroup = { "a","b","c"};
string[] members = new string[3]; // 3명이고 인덱스는 0,1,2
```

string[]는 문자열의 배열이라는 의미. 배열을 선언할 때는 데이터 타입 뒤에 []를 붙혀야함



```
for (string e : members) {
e에 관한 실행문
}
```

배열 members의 값을 변수 e에 담아서 중괄호 구간 안으로 전달해 줌



한계 : 초기화 할 때 크기가 정해짐  -> 컬렉션 기능을 이용하면 유연하게 사용 가능



# 메소드 정의와 호출

```
public static void main(string[] args){

  numbering(); // 호출된 메소드

}

public static void numbering(){ //메소드 정의
}
```

정의와 호출의 차이점  : ()로 끝나면 호출된 메소드 {}로 되면 정의



main

main 메소드는 규칙 , 만들고 싶은 프로그램이 있다면 반드시 main 안에 넣어야함

메소드를 씀으로서 재활용이 가능 -> 중복되는 부분을 없앨 수 있고 수정이 용이하다



- 외부 자극 : 입력, 반응 : 출력 /메소드는 프로그램 안에서 동작하는 하나의 작은 프로그램. 입력값에 따라  출력값도 달라지게 할수도

-> 매개변수 parameter 를 통해 이루어진다. 메소드를 정의할 때 ()안에 변수를 넣고 호출할때 인자값을 넣어서 호출. 복수값도 가능

- 결과값을 화면에 출력하지 않고 그냥 반환 받고 싶을 때는 return을 사용한다. return 은 값을 반환시키기도 하지만 메소드를 중단시키기도 한다. 또한 이때는 반환할 값의 데이터 형식을 메소드의 이름 옆에 명시해주어야한다. 반환값이 없으면 void

```
 public static void main(String[] args) {
        String result = numbering(1, 5);
        System.out.println(result);
```

여러개의 데이터를 반환받고 싶을 땐? 배열을 이용한다.

```
public class ReturnDemo4 {
 
    public static String[] getMembers() {
        String[] members = { "최진혁", "최유빈", "한이람" };
        return members;
    }
 
    public static void main(String[] args) {
        String[] members = getMembers();
        }
```

------------------------------------------------------------





보완할것 : 연산자 

# 입력과 출력

string[] args : 매개변수 메소드가 호출될 때 전달된 입력 값을 메소드 내부로 전달

```
class inputdemo {
 public static void main( string[] arge){   
  for(String e : args){
  	system.out.println(e);
  }
 }  // 사용자로부터 arge라는 문자열배열에 값을 입력받아서 그 값들을 for문을 이용해 하나씩 출력
}
```

- system.in : 실행되면 자바는 사용자의 입력이 있을 때 까지 변수 i에 값을 할당하지 않고 대기상태에 있게 된다. 

앱이 실행중에 입력 받기

```
import java.util.Scanner;
 
public class ScannerDemo {
 
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in); //사용자가 입력한 값을 스캐너가 스캐닝 알아냄 . 그걸 sc에 저장!
        int i = sc.nextInt(); //실행을 멈추고 입력을 다 하는걸 기다리고 있는 상태에서 입력받으면 아이에저장돼어 계산 후 끝냄...
        System.out.println(i*1000); 
        sc.close();
    }
```



출력

```
System.out.print(); // 다음에 출력하는 것이 바로 뒤에 붙어서 출력
System.out.println(); // 다음에 출력하는 것이 한줄 띄어서 출력
```



